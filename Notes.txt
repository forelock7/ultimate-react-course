*****************************************************************************************************************
Section 3: A First Look at React
*****************************************************************************************************************

- Vanila JS - pure JS without any framework, but can be Jquery

- Vanila JS vs React: https://codesandbox.io/s/react-first-app-advice-52879f

- React - JS library for building user interfaces. 
1) Based on components - combining blocks of complex UI
2) Declarative 
 + describe how components look like and how they work using a declarative syntax called JSX.  
 + Declarative telling React what a component shoulld look like, based on current data/State
 + React is abstraction away from DOM: we never touch the DOM(like vanilla JS)
 + JSX: a syntax that combines HTML, CSS, JS as well as referencing other components.
3) State-driven: REACT reacts to state changes by re-rendering the UI. State -> Render -> UI(Component written with JSX) -> Action on UI -> Update state -> Re-render -> UI
4) JS library - React is just library (not framework), because it's only the 'view' layer. We need to pick multiple external libraries to build a comlete application. Complite frameworks built on top of React - NEXT.js, Remix
5) Extremely popular - a lot of companies use React
6) Created by facebook in 2011 by Jordan Walke

- Two option for setting up a project
1) create-react-app (complete 'starter kit', ESLint, Prettier, Jest etc) - slow and outdated technologies. It's used for small projects.
2) VITE - modern too. Need to manually set up ESLint. Extrimaly fast host replacement (HMR) and bundling. It's used for real projects

- NEXT.js and Remix framework provide more functionality than Vanila React by itself.

- Create React project from scratch using 'create-react-app' 
npx create-react-app@5 pizza-menu

- To run JS/TS inside VScode use 'Quokka.js' extansios

*****************************************************************************************************************
Section 5: Working With Components, Props, and JSX
*****************************************************************************************************************

- Start React project 
npm run start

- React apps are entirely made out of components
- building blocks of user inerfaces in React
- Piece of UI that has its own 'data', 'logic' and 'appearance' (how it works and looks)
- We build complex UIs by building multiple components and combining them
- Components can be reused, nested inside each other and pass data between them

- Component tree - to understand the structure (Parent and child components)

- Rules for functions of components:
1) function name must start with capital letter 
2) function must return murkup (html)
3) Each component can return only one element (correct: <div><h1>Bla</h1><h2>Bla</h2></div>, wrong: <h1>Bla</h1><h2>Bla</h2>)
4) Never nest component function in component function

- Component:
+ data
+ logic
+ appearance

- JSX:
  + Declarative syntax to describe what components look like and how they work
  + Components must return a block of JSX
  + Extension of JS that allows us to embed following elements into HTML:
    1) JS
    2) CSS
    3) React Components

- BABEL in React convert HTML with JSX into JS. (you can use just JS functions instead of JSX syntax)

- Imperative approach - "How to do this" - create elements via Vanila JS 
   + Manual DOM element selections and DOM traversing.
   + Step-by-Step DOM mutation until we reach the desired UI
- Declarative approach - "What we want"
   + Describe what UI should look like using JSX, based on current data
   + React is an abstraction away from DOM: we never touch the DOM
   + Instead, we think of the UI as a reflection of the current data

- alert can happen twice because of 'strict' mode 

- One technology per file (traditional)
- One component per file (React new paradigm)

- Use JS code in JSX syntax - just cover with {}
        <p>{props.ingredient}</p>

- props in React: if you need use something except string - use JS mode {}
      <Pizza
        name="Pizza Spinaci"
        ingredient="Tomato, mozarella, spinach, and ricotta cheese"
        photoName="pizzas/spinaci.jpg"
        price={10}
      />

- Props are used to pass data from parent to child component

- Props are read-only, they are immutable. This is one of React's strict Rules

- If you need to mutate props, you actually need state

- One-way Data Flow - Data can pass only from parent top child!!! (Angular has two-way data flow)
    + more predictable
    + easier to debug
    + more performant

- Challenge #1: https://codesandbox.io/s/profile-card-v1-2hrm4p?file=/src/index.js

- In JS mode {} you can place JS expression (reference vars, create arrays or objects, [].map, ternary operator)
- In JS mode statements are not allowed (if/else, for, switch)
- JSX can be written anywhere inside components (in if/else, assign to vars, pass it into functions)
- Piece of JSX can only have one root element. If you need more, use <Raact.Fragment> (or the short <>)

- If we use iteration in React, you should use 'key' unique property to avoid console log errors
function Menu() {
  return (
    <main className="menu">
      <h2>Our menu</h2>

      <div>
        {pizzaData.map((pizza) => (
          <Pizza pizzaObj={pizza} key={pizza.name} />
        ))}
      </div>
    </main>
  );
}

- Shortcircuting in React. Use only boolean value (NOT truthy or falsy value), because boolean values are not returned:
      {numPizzas > 0 && (
        <ul className="pizzas">
          {pizzas.map((pizza) => (
            <Pizza pizzaObj={pizza} key={pizza.name} />
          ))}
        </ul>
      )}

- In LS mode we can use if/else statement or any other JS code, except code that produce some value

- common technic to return 'null'
function Pizza(props) {
  if (props.pizzaObj.soldOut) return null;
  return (
    <li className="pizza">
      <img src={props.pizzaObj.photoName} alt={props.pizzaObj.name} />
      <div>
        <h3>{props.pizzaObj.name}</h3>
        <p>{props.pizzaObj.ingredients}</p>
        <span>{props.pizzaObj.price}</span>
      </div>
    </li>
  );
}

- props can be destructuring
function Pizza(props)
function Pizza({ pizzaObj })

- React fragment - use if you need to combane 2 elements without wrappimg them into another one
        <>
          <p>
            Authentic Italian cuisine. 6 creative dishes to choose from. All from our stone oven,
            all organic, all delicious.
          </p>
          <ul className="pizzas">
            {pizzas.map((pizza) => (
              <Pizza pizzaObj={pizza} key={pizza.name} />
            ))}
          </ul>
        </>

- if you need add some key to React fragment, just use following fragment
<React.Fragment key={ghdsghd}>
.....
</ React.Fragment>

- three options in JSX
      <span>
        {level === "advanced" && "üí™"}
        {level === "intermediate" && "üëç"}
        {level === "begginer" && "üê£"}
      </span>

*****************************************************************************************************************
Section 6: State, Events, and Forms: Interactive Components
*****************************************************************************************************************

- Set style for element
        <button style={{ backgroundColor: '#7950f2', color: '#fff' }}>Previous</button>

- Set click event for element ('onClick')
<button style={{ backgroundColor: '#7950f2', color: '#fff' }} onClick={() => alert('Next')}>

- Alert Function immidiatly run (NOT valid for this case)
<button onClick={alert('Next')}>

- Mouse handler
onMouseEnter={() => alert('TEST')}

- Another way to define handler function
  ........
  function handlePrevious() {
    alert('Previous');
  }
  return (
    ........
        <button style={{ backgroundColor: '#7950f2', color: '#fff' }} onClick={handlePrevious}>
    ........

- State - data that a component can hold over time, necessary for information that it needs to remember throughout the app's lifecucle
- "Component's memory"
- Component state - single local component variable ("Piece of state", "State variable")
- Updating component state triggers React to re-render the component

- Component View - when component is rendered

- State allows:
    1) Upfate the component's view (by re-rendering)
    2) Persist local variables between renders

- Use state in code, where 'step' - variable, 'setStep' - function to update state, 'useState' - function to create a state with init value
  const [step, setStep] = useState(1);
  function handlePrevious() {
    if (step > 1) setStep(step - 1);
  }

- Do NOT update state like this:
step = step + 1

- Update State -> Re-render component -> View
- In React, a view is updated by re-rendering the component
- A component is re-rendered when its state is updated
- DATA <-> UI

- Use ONLY callback function to update State
    if (step < 3) setStep((s) => s + 1);
    // BAD PRACTICE:
    if (step < 3) setStep(step + 1);

- UI as a function of state. UI as a reflection of data changing pver time

- For data that should not trigger re-rendering UI do not use state

- Prevent default action when submit form
function Form() {
  function handleSubmit(e) {
    e.preventDefault();
  }
  return (
    <form className="add-form" onSubmit={handleSubmit}>
    .....

- State 
  + internal data, owned by component
  + Component "memory"
  + Can be updated by component itself
  + Updating state causes component to re-render
  + Used to make components interactive

- Props:
  + External data, owned by parent component
  + Similar to function parameters
  + Read-only
  + Receiving new props causes component to re-render. Usually when the parent's state has been updated
  + Used by parent to configure child component ("settings")

  - https://codesandbox.io/s/react-exercise-flashcards-starter-sx254w?file=/src/App.js
  - https://codesandbox.io/s/date-counter-v2-d23kg4?file=/src/App.js

*****************************************************************************************************************
Section 7: Thinking In React: State Management
*****************************************************************************************************************

- The "Thinking in React" process:
  1. Break the desired UI into components and estabish the component tree
  2. Build a static version in React (without state)
  3. Think about state:                                       |
    + When to use state                                       |
    + Types of state: local vs global                         |
    + Where to place each piece of state                      | State managment
  4. Establish data flow:                                     |  
    + One-way data flow                                       |
    + Child-to-parent communication                           |
    + Accessing global state                                  |

- Local State - only for one or few components, child components
- Global State - many components. Shared state that accessible to every component in the entire applicatio. (by React Context API, Redux). Use firstly local state!!!!

- Pass function as props:
      export default function App() {
        ....
        function handleAddItems(item) {
          setItems((items) => [...items, item]);
        }
        return (
          <div className="app">
            ....
            <Form onAddItems={handleAddItems} />
            ....
          </div>
        );
      }
      function Form({ onAddItems }) {
          ......
          onAddItems(newItem);
          ......
        }

- "Lifting Up State" - just moving state of component to parent component if you need access to state of several sibling component. 
Child-to parent communication (inverse data flow): child updating parent state (data "flowing" up). Use set function of state in child to update state.

- Derived state(–ø–æ—Ö—ñ–¥–Ω–∏–π) - state that is computed from an existing piece of state or from props
Do not need to devide state of object to several states of elements of that object. Just use regular vars, no useState. State of object is the single state of thruth for related data.

- Sort items in alphabetical order
if (sortBy === 'description') sortedItems = items.slice().sort((a, b) => a.description.localeCompare(b.description));

- Sort by boolean and number:
  if (sortBy === 'packed') sortedItems = items.slice().sort((a, b) => Number(a.packed) - Number(b.packed));

  - 'children' Props
  props.children
  Example:
            <Button textColor="#fff" bgColor="#7950f2" onClick={handlePrevious}>
              <span>üëà</span> Previous
            </Button>
            ......
            function Button({ textColor, bgColor, onClick, children }) {
              return (
                <button style={{ backgroundColor: bgColor, color: textColor }} onClick={onClick}>
                  {children}
                </button>
              );
            }

- Work with current state inside setState method
    const [selectedFriend, setSelectedFriend] = useState(null);
    function handleSelection(friend) {
      setSelectedFriend((cur) => (cur?.id === friend.id ? null : friend));
    }

*****************************************************************************************************************
Section 10: Thinking in React: Components, Composition, and Reusability
*****************************************************************************************************************

- Split a UI into component:
  1) Logical separation of content/layout
  2) Reusability
  3) Resposibility / complexity
  4) Personal coding style

- Start from building big component and then split it if necessary

- Categories of Components:
  1) Stateless / presentational components - no state, can receive props and simply present received data or other content, usually small and reusable
  2) Stateful components - have state, can still be reusable
  3) Structural components - pages/layouts/screens of app, result of composition, can be huge and non-reusable(but don't have to)

- Component Composition:
1.
  function Model() {
    return (
      <div>
        <Success />
      </div>
    )
  }
2. - makes component reusable!!!!!
  function Model({ children }) {
    return (
      <div>
        {children}
      </div>
    )
  }

- Passing Elements as props
    <Box element={<Movie />} />
  instead of 
    <Box>
      <Movie />
    </Bob>

- Props as an API of component - try to have balance of props, their number should be enough, but not too many
    <StarRating maxRating={5} messages={['Terrible', 'Bad', 'Okay', 'Good', 'Amazing']} />
    <StarRating maxRating={5} color="red" className="test" defaultRating={3} />
    ......
    export default function StarRating({
      maxRating = 5,
      color = '#fcc419',
      size = 48,
      className = '',
      messages = [],
      defaultRating = 0,
    }) 

- Validation of props type. This approach is outdated. Now just use TypeScript
    import PropTypes from 'prop-types';
    StarRating.propTypes = {
      maxRating: PropTypes.number,
      defaultRating: PropTypes.number,
      color: PropTypes.string,
      size: PropTypes.number,
      messages: PropTypes.array,
      className: PropTypes.string,
      onSetRating: PropTypes.func,
    };

*****************************************************************************************************************
Section 11: How React Works Behind the Scenes
*****************************************************************************************************************

- Component -> Component Instance -> React Element -> DOM Element (HTML)

- How components are displayed on the screen:
  1. Trigger (Render is triggered (Updating State))
  2. Render Phase (React calls component funcs and figures out how DOM should be updated) - it's quite different than rendering UI
  3. Commit Phase (React actually writes to the DOM, updating, inserting and deleting elements)
  4. Browser paint

- The render process is triggered for the enire application
- In practice, it looks like React only re-render the component where the state update happens, but that's not how it works behind the Scenes
- Renders are not triggered immediately, but scheduled for when the JS engine has some "free time". There is also batching of multiple setState calls in event handlers

- Rendering in React is calling component function, not updating screen/DOM
- Virtual DOM - React element(component) tree
- Rendering a component will cause all of its child components to be rendered as well (no matter if props changed or not). Necessary because React doesn't know whether children will be affacted
- Reconciliation - deciding which DOM elements actually need to be inserted, deleted or updated in order to reflect the latest state changes.
- Reconciler - engine of React. It allows us never touch DOM directly, instead tells the React how next snapshot of UI should look like.
- Fiber is current reconciler of React. It takes React element tree (virtual DOM) and builds Fiber Tree based on it.
- Fiber tree - internal tree that has a 'fiber' for each component instance and DOM element. Fibers are NOT re-create on every render, it's mutable!
- Work can be done asynchronously - Rendering process can be split into chunks, tasks can be prioritized and work can be paused, reused or thrown away. Enables concurrent features like Suspense or transitions. Long renders won't block JS engine
- After updating of Virtual DOM executes Reconciliation + Diffing - compering current fiber tree with new Virtual DOM and updating Fiber Tree (build workInProgress tree) 
- List of effects (List of DOM updates) - result of Render Phase

- Commit Phase - updating DOM based on "List of DOM updates"
- Committing is synchronous: DOM is updated in one go, it can't be interrupted.

- After the Commit phase completes, the workInProgress fiber tree becomes the current tree for the next cycle
- Browser paint - is next after Commit phase - updated UI on the sceen.

1. Trigger (change state)
2. Render Phase - is performed by 'React' (never touch the DOM)
3. Commit Phase - is performed by 'ReactDOM'(browsers), 'React Native' (IOS, android), 'Remotion' (video) etc.
4. Browser Paint - is performed by browser (or IOS, android, video etc)

- Diffing uses 2 fundamental assumption (rules):
  1. Two elements of different types will produce different trees
  2. Elements with a stable key prop stay the same across renders

- Two situation:
  1. Same position, DIFFERENT element:
    + React assumes entire sub-tree is no longer valid
    + Old components are destroyed and removed from DOM, including state
    + Tree might be rebuild if children the same (state is reset)
  2. Same position, SAME elements, but some props are changed:
    + Element will be kept (as well as child elements), including state
    + New props / attributes are passed if they changed between renders
    + Sometimes this is not what we want... Then we can use the key prop

- Key Prop - special that we use to tell the diffing algorithm that an element is unique
  + Allows React to distinguish between multiple instances of the same component type
  + When a key stays the same across renders, the element will be kept in the DOM (even if the position in the tree changes)
    1. Using keys in List
  + When a key changes between renders, the element will be destroyed and a new one will be created (even if the position in the tree is the same as before)
    2. Using key to reset state

- Types of logic in React components
  1. Render logic
    + top level of the component function
    + describes how component view looks like
    + execute every time the component renders
  2. Event handler functions
    + executed as a consequence of the event that the handler is listening for
    + code that actually update state, perform an HTTP requests, read an input field, navigate to another pages

- Functional programming principales:
  + Side effect: dependancy on or modification of any data outside the function scope. Interaction with the outside world(mutating external vars, HTTP requests, writing DOM)
      const areas = {};
      function circleArea(r) {
        areas.circle = 3.14 * r * r;
      }
  + Pure function: has no side effects. Does not change any vars outside its scope. Give the same input, a pure function always returns the same output
      function circleArea(r) {
        return 3.14 * r * r;
      }
  + Inpure function (first function is also inpure):
      function circleArea(r) {
        const date = Date.now();       <---------
        const area = 3.14 * r * r;
        return `${date}: ${area}`
      }

- Rules for Render logic"
  + Components must be pure when it comes to render logic: given the same props(input), a component instance should always return the same JSX (output)
  + Render logic must produce no side effects: no interactions with 'outside world' is allowed:
    * Do NOT perform network requests (API calls)
    * Do NOT start timers
    * Do NOT directly use the DOM API
    * Do NOT mutate objects or vars outside the function scope
    * Do NOT update state (or refs): this will create an infinite localeCompare
- Side effects are allowed (and encouraged) in event handler functions. There is special hook to register side effects (useEffect)

- How State updates are batched:
  const reset = function() {
    setAnswer('');
    console.log(answer);
    setBest(true);
    setSolved(false);
  }
- React will update all 3 states together and then render and commit. So answer !== ''.
- If we need update state based on previous update, use setState with callback:
    console.log(setAnswer(answer => ...));

- React 18+ supports not only 'Event Handlers' as React 17, but also:
  + Timeouts
  + Promises
  + Native Events

  - Use callback function to update state and use it again in the same function
    function handleTripleInc() {
      // setLikes(likes + 1); // 1
      // setLikes(likes + 1); // 1
      // setLikes(likes + 1);  // 1
      setLikes((likes) => likes + 1); // 1
      setLikes((likes) => likes + 1); // 2
      setLikes((likes) => likes + 1); // 3
    }

- Event propagation in the browser
1. New Event object created in the root element, 'html', and travels to the target, where event was triggered, for instance 'button' (Capturing phase)
2. Then Event object travels to root back (Bubling phase)
- By default event handlers listen to events on the target and during the building phase
- We can prevent bubbling with 
    e.stopPropagation();

- Event delegation:
  + Handling events for multiple elements centrally in one single parent element
  + Better for performance and memory, as it needs only one handler function:
      1. Add handler to parent (.options)
      2. Check for target element (e.target)
      3. If target is one of the <button>s, handle the event
- It's very common for vanilla JS apps, but not so much in React

- React registers all event handlers on the root DOM container. This is where all events are handled.
- Behind the scenes, React performs event delegation for all events in our application

- React uses SyntheticEvent - is wrapper around DOMs native event object (PointerEvent, MouseEvent, KeyboardEvent...)
- It has the same interface as native event objects, like stopPropagation() and preventDefault()
- Fixes browser inconsistencies, so that events work in the exect same way in all browsers
- Most synthetic events bubbles (including focus, blur and change), except scroll

- Difference of events in React from vanila JS:
    1. Attributes for event handlers are named using camelCase (onClick instead of onclick or click)
    2. Default behavior can NOT be prevented by returning false (only by using preventDefault())
    3. Attach 'Capture' if you need to handle during capture phase (example: onClickCapture)

- Library vs Framework: React is library!
- Framework - includes all you need. Like Angular: HTTP request, Styling, Routing, Form Management
- Library - just used for particular part. React - just for view, except React you also need to use other 3rd-party libraries for HTTP request, Styling, Routing, Form Management

- React 3rd party library ECOSYSTEM:
  1. Routing (for SPAs): React Router, React Location
  2. HTTP requests: JS fetch(), Axios
  3. Remote state management: React Query, SWR, Apollo
  4. Global state management: Context API, Redux, Zustand
  5. Styling: CSS Modules, Styled components, tailwindcss
  6. Form management: React Hiik Form, FORMIK
  7. Animations/transitions: Motion, React-spring
  8. UI components: Mi, chakra, Mantime

- Opinionated React frameworks: Next.js, Remix, Gatsby. It's alternative for first approach

- Summary
  - Component - is like blueprint for a piece of UI. React creates a component instance. When a component instance is rendered, it will return React element
  - Rendering - calls component functions and calculating what DOM elements need to be updated/ Each time a component instance is rendered or re-rendered, the function is called again
  - Only the initial app render and state updates can cause a render, which happens for the entire app
  - When a component instance gets re-rendered, all its children will get re-render as well. This doesn't mean that all children willget updated in the DOM, thanks reconciliation, 
    which checks which element actually changed between two renders. But all this re-rendering can still have impact on performance (more on that later in the cource)
  - Diffing is how decided which DOM elements need to be added or modified.
  - Giving elements a key prop allows React to avoid destroying elements or reset state
  - Never declare a new component inside another component
  - The logic that produces JSX output for a component instance ("render logic") is not allowed to produce any side effects: no API calls, no timers, no object or variable mutations, no state updates. 
    Side effects are allowed in event handlers and useEffect
  - The DOM is updated in the commit phase, but not by React, but by a "rendered" called ReactDOM
  - Multiple state updates inside the handler function are batched, so it happens only one re-render.
  - Synthetic event object
  - React is a library, not a framework.

*****************************************************************************************************************
Section 12: Effects and Data Fetching
*****************************************************************************************************************

- REPO: 07-usepopcorn/usepopcorn

- Component lifecycle:
    1. Mount / Initial render
        + Component instance is rendered for the first time
        + Fresh state and props are created
    2. Re-render 
        + State changes
        + Props change
        + Parent re-render
        + Context changes
    3. Unmount
        + Component instance is destroyed and removed
        + State and props are destroyed

- Side effect is basically any "interaction between a React component and the world outside the component". 
Also when code that actually does something: data fetching, setting up subscriptions, setting up timers, manually accessing the DOM

- Side effects:
  + Event handlers - prefered way of using side effect function
  + EFFECTS (useEffect) - allows us to write code that will run at different moments: mount, re-render or Unmount

  useEffect(function () {
    fetch(`http://www.omdbapi.com/?apikey=${KEY}&s=interstellar`)
      .then((res) => res.json())
      .then((data) => {
        setMovies(data.Search);
      });
      return () => console.log('Cleanup') // Cleanup function
  }, []); // [] - Dependancy array

- Using async function instead of Promise:
    useEffect(function () {
      async function fetchMovies() {
        const res = await fetch(`http://www.omdbapi.com/?apikey=${KEY}&s=interstellar`);
        const data = await res.json();
        setMovies(data.Search);
      }
      fetchMovies();
    }, []);

- Loader:
    const [isLoading, setIsLoading] = useState(false);
    useEffect(function () {
      async function fetchMovies() {
        setIsLoading(true);
        const res = await fetch(`http://www.omdbapi.com/?apikey=${KEY}&s=interstellar`);
        const data = await res.json();
        setMovies(data.Search);
        setIsLoading(false);
      }
      fetchMovies();
    }, []);
    .....
    <Box>{isLoading ? <Loader /> : <MovieList movies={movies} />}</Box>

- Handling errors
  see REPO: 07-usepopcorn/usepopcorn/App.js
  ....
        <Box>
          {/* {isLoading ? <Loader /> : <MovieList movies={movies} />} */}
          {isLoading && <Loader />}
          {!isLoading && !error && <MovieList movies={movies} />}
          {error && <ErrorMessage message={error} />}
        </Box>

- Depedancy array
  + By default, effects run after every render. It can be prevented by a dependency array
  + Each time one of the dependancies changes, the effect will be executed again
  + Every state variable and prop used inside the effect MUST be included in the dependency array
      - otherwise, we get a 'stale closure'.

- effect synchronization:
  + useEffect(fn, [x, y, z]) - effect synch with x, y, z/ Runs on mount and re-renders triggered by updayting x, y, z
  + useEffect(fn, []) - effect synch with no state/props. Runs only on mount (initial render)
  + useEffect(fn) - effect synch with everything. Runs on every render (usualy bad ‚õîÔ∏è)

- Effect executed after mount-commit-browser_paint
- Layout effect - another type of effect that is very rarely necessary (useLayoutEffect). It executs after commit and before browser_paint

- Example effect synch:
    useEffect(
      function () {
        async function fetchMovies() {
          try {
            setIsLoading(true);
            setError('');
            const res = await fetch(`http://www.omdbapi.com/?apikey=${KEY}&s=${query}`);
            if (!res.ok) new Error('Something went wrong with fetching movies');

            const data = await res.json();
            if (data.Response === 'False') throw new Error('Movie not found');
            setMovies(data.Search);
          } catch (err) {
            console.error(err.message);
            setError(err.message);
          } finally {
            setIsLoading(false);
          }
        }
        if (query.length < 3) {
          setMovies([]);
          setError('');
          return;
        }
        fetchMovies();
      },
      [query],
    );

- useEffect should do only ONE action!!!

- Cleanup function can be returned from a effect(optional)
- It runs:
    + before the effect is executed again
    + after component has unmounted!!!  

- whenever the side effect keeps happening after the component has been re-rendered or unmounted

- Examples of cleanup:
    Effect-------------|  Potential Cleanup---
    HTTP request       |  Cancel requests
    API subscriptions  |  Cancel subscription
    Start timers       |  Stop timer
    Add event listener |  Remove listener

- Cleanup function to return back default page title
  useEffect(
    function () {
      if (!title) return;
      document.title = `Movie | ${title}`;
      return function () {
        document.title = 'usePopcorn';
      };
    },
    [title],
  );

- Cleanup to cancel http requests that occures after re-rendering component.

  useEffect(
    function () {
      const controller = new AbortController();

      async function fetchMovies() {
        try {
          setIsLoading(true);
          setError('');
          const res = await fetch(`http://www.omdbapi.com/?apikey=${KEY}&s=${query}`, {
            signal: controller.signal,
          });
          if (!res.ok) new Error('Something went wrong with fetching movies');

          const data = await res.json();
          if (data.Response === 'False') throw new Error('Movie not found');
          setMovies(data.Search);
          console.log(data.Search);
          setError('');
        } catch (err) {
          console.error(err.message);

          if (err.name !== 'AbortError') {
            setError(err.message);
          }
        } finally {
          setIsLoading(false);
        }
      }
      if (query.length < 3) {
        setMovies([]);
        setError('');
        return;
      }
      fetchMovies();

      return function () {
        controller.abort();
      };
    },
    [query],
  );

- One more example of clean up:
  useEffect(
    function () {
      if (!title) return;
      document.title = `Movie | ${title}`;
      return function () {
        document.title = 'usePopcorn';
        // console.log(`Clean up effect for movie ${title} (Explaination of a closure)`);
      };
    },
    [title],
  );

- use effect to close movie's details by pressong  'Esc' button:
  useEffect(
    function () {
      function callback(e) {
        if (e.code === 'Escape') {
          onCloseMovie();
          console.log('CLOSING');
        }
      }
      document.addEventListener('keydown', callback);

      return function () {
        document.removeEventListener('keydown', callback);
      };
    },
    [onCloseMovie],
  );

  - disable elements if something is loading:
      <select
        value={fromCur}
        onChange={(e) => setFromCur(e.target.value)}
        disabled={isLoading}
      >

*****************************************************************************************************************
Section 13: Custom Hooks, Refs, and More State
*****************************************************************************************************************

- React HOOKS:
    + special built-in functions that allow us hook into React internals:
        - Creating and accessing state from Fiber tree
        - Registring side effects in Fiber tree
        - Manual DOM selections, etc
    + Always start with 'use' word
    + can compose multiple hooks into our own custom hooks
    + give function component the ability to own state and run side effects at different lifecycle points

- Most popular hooks:
    + useState
    + useEffect
    + useReducer
    + useContext
    + useRef
    + useCallback
    + useMemo
    + useTransition
    + useDeferredValue, etc

- Rules of HOOKS:
    + Only call hooks at the top level
    + Only call hooks from React functions
- All tese rules are automatically enforced by React's ESLint rules

- Hook relies on call order

- Derive state. If put boolean expression into component, it will be calculated each time during re-rendering:
    const isTop = imdbRating > 8;
    console.log(isTop);

- To update value in handle function:
  function handleAdd() {
    const newWatchedMovie = {
      imdbID: selectedId,
      title,
      year,
      poster,
      imdbRating: Number(imdbRating),
      runtime: Number(runtime.split(' ').at(0)),
      userRating,
    };
    onAddWatched(newWatchedMovie);
    ///////////////// see below
    setAvgRating(Number(imdbRating));
    setAvgRating((avgRating) => (avgRating + userRating) / 2);
  }

- Save data in local storage:
      const [watched, setWatched] = useState(function () {
        const storedValue = localStorage.getItem('watched');
        return JSON.parse(storedValue);
      });

      useEffect(
        function () {
          localStorage.setItem('watched', JSON.stringify(watched));
        },
        [watched],
      );

- Creating State:
    1. Simple                               -----  const [count, setCount] = useState(23);
    2. Based on function (lazy evaluation)  -----  const [count, setCount] = useState(
                                                      () => lacolStorage.getItem('count');
                                                    )
        function - pureand without arguments
        called only on initial render
                                  
- Updating state:
    1. Simple                               -----  setCount(1000);
    2. Based on current state               -----  setCount((c) => c + 1);
        function - pure and return next state
        Make sure to NOT mutate objects or arrays, but to replace them

- Bad practice manipulate with DOM directly in React (use useRef instead this case):
    function Search({ query, setQuery }) {
      useEffect(function () {
        const el = document.querySelector('.search');
        console.log(el);
        el.focus();
      }, []);

      return (
        <input
          className="search"
          type="text"
          placeholder="Search movies..."
          value={query}
          onChange={(e) => setQuery(e.target.value)}
        />
      );
    }

- useRef - "Box" (object) with a mutable .current property that is persisted across renders ("normal" variables are always reset)
- Two big use cases:
    1. Creating a variable that stays the same between renders (previous state, setTimeout id)
    2. Selecting and storing DOM elements

- Refs are for data that is NOT rendered: usually only appear in event handlers or effects, not in JSX (otherwise use state)
- do NOT read write or read .current in render logic (like state)

- Differense | Persist across renders | Updating re-render | Immutable | Asynch updates |
    State    |          +             |         +          |     +     |        +       |
    refs     |          +             |         -          |     -     |        -       |

- useRef for focus element:
      const inputEl = useRef(null);

      useEffect(function () {
        inputEl.current.focus();
      }, []);

      return (
        <input
          className="search"
          type="text"
          placeholder="Search movies..."
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          ref={inputEl}
        />
      );
    }

- press 'Enter' key to clear search field if it's focused
    useEffect(
      function () {
        function callback(e) {
          if (document.activeElement === inputEl.current) return;

          if (e.code === 'Enter') {
            inputEl.current.focus();
            setQuery('');
            console.log('ENTER');
          }
        }
        document.addEventListener('keydown', callback);
        return () => document.addEventListener('keydown', callback);
      },
      [setQuery],
    );

- Custom hooks:
    + must start with "use" word
    + UI (component) and LOGIC (regular functions, custom hooks)
    + always non-visual logicone custom hooks should have one purpose
    + rules of hooks apply to custom hooks too
    + custom hook can have regular hooks inside

- Example of custom hook export function useLocalStorageState(initialState, key) {
    const [value, setValue] = useState(function () {
      const storedValue = localStorage.getItem(key);
      return storedValue ? JSON.parse(storedValue) : initialState;
    });

    useEffect(
      function () {
        localStorage.setItem(key, JSON.stringify(value));
      },
      [value, key],
    );

    return [value, setValue];
  }

  - CHALLENGE: useGeolocate. (case when hook returns also function):
      https://codesandbox.io/p/sandbox/react-challenge-usegeolocation-tkqszl?file=%2Fsrc%2FApp.js%3A60%2C1

            function useGeolocation() {
              const [isLoading, setIsLoading] = useState(false);
              const [position, setPosition] = useState({});
              const [error, setError] = useState(null);

              function getPosition() {
                if (!navigator.geolocation)
                  return setError("Your browser does not support geolocation");

                setIsLoading(true);
                navigator.geolocation.getCurrentPosition(
                  (pos) => {
                    setPosition({
                      lat: pos.coords.latitude,
                      lng: pos.coords.longitude,
                    });
                    setIsLoading(false);
                  },
                  (error) => {
                    setError(error.message);
                    setIsLoading(false);
                  }
                );
              }
              return { isLoading, position, error, getPosition };
            }

            export default function App() {
              const [countClicks, setCountClicks] = useState(0);

              function handleClick() {
                setCountClicks((count) => count + 1);
                getPosition();
              }

              const {
                isLoading,
                position: { lat, lng },
                error,
                getPosition,
              } = useGeolocation();

              return (
                <div>
                  <button onClick={handleClick} disabled={isLoading}>
                    Get my position
                  </button>

                  {isLoading && <p>Loading position...</p>}
                  {error && <p>{error}</p>}
                  {!isLoading && !error && lat && lng && (
                    <p>
                      Your GPS position:{" "}
                      <a
                        target="_blank"
                        rel="noreferrer"
                        href={`https://www.openstreetmap.org/#map=16/${lat}/${lng}`}
                      >
                        {lat}, {lng}
                      </a>
                    </p>
                  )}

                  <p>You requested position {countClicks} times</p>
                </div>
              );
            }

*****************************************************************************************************************
Section 14: [Optional] React Before Hooks: Class-Based React
*****************************************************************************************************************

- Optional. Outdated approach

*****************************************************************************************************************
Section 16: The Advanced useReducer Hook
*****************************************************************************************************************

- useReducer hook
    const initialState = { count: 0, step: 1 };
    function reducer(state, action) {
      console.log(state, action);

      switch (action.type) {
        case 'dec':
          return { ...state, count: state.count - 1 };
        case 'inc':
          return { ...state, count: state.count + 1 };
        case 'setCount':
          return { ...state, count: action.payload };
        case 'setStep':
          return { ...state, step: action.payload };
        case 'reset':
          return initialState;
        default:
          throw new Error('Unknown action');
      }
    }

    function DateCounter() {
      const [state, dispatch] = useReducer(reducer, initialState);
      const { count, step } = state;

      // This mutates the date object.
      const date = new Date('june 21 2027');
      date.setDate(date.getDate() + count);

      const dec = function () {
        dispatch({ type: 'dec' });
      };

        const defineCount = function (e) {
        dispatch({ type: 'setCount', payload: Number(e.target.value) });
      };

        const reset = function () {
        dispatch({ type: 'reset' });
      };
      ......

- Why reducer:
    1. a lot of state vars and state updates spread across many handlers
    2. multiple updates need to happen at the same time
    3. Updating a piece of state  depends on one or multiple other pieces of state

- useRedicer:
    + alternative way to set state, ideal for complex state and related pieces of state
    + stores related pieces of state in a state object (see above)
    + useReducer needs reducer: func contains all logic to update state
    + reducer: pure func (no side effects) that takes current state and action, and returns the next state
    + action: object that describes how to update state
    + dispatch: func to trigger state updates by sending action from event handlers to the reducer (agreed to use scheme: { type: '...', payload: ... })

- Install fake server:
    npm i json-server

      "scripts": {
        "server": "json-server --watch ./data/cities.json --port 8000"
        ......

- Use reduce function to calculate sum:
  const maxPossiblePoints = questions.reduce((prev, cur) => prev + cur.points, 0);

- Clean up function to stop timer between renders
    function Timer({ dispatch, secondsRemaining }) {
      useEffect(
        function () {
          const id = setInterval(function () {
            dispatch({ type: 'tick' });
          }, 1000);

          return () => clearInterval(id);
        },
        [dispatch],
      );
      return <div className="timer">{secondsRemaining}</div>;
    }

- CHALLENGE #1: Creating a Bank Account With useReducer: https://codesandbox.io/p/sandbox/react-challenge-usereducer-bank-starter-forked-3xmr2v?file=%2Fsrc%2FApp.js

*****************************************************************************************************************
Section 17: React Router: Building Single-Page Applications (SPA)
*****************************************************************************************************************

- Set up Vite project
    + Install project via Vite:
        npm create vite@latest
    + Run Vite project
        npm run dev
    + Install Eslint:
        npm install eslint vite-plugin-eslint eslint-config-react-app --save-dev
    + Create file: /worldwise/.eslintrc.json
        {
          "extends": "react-app"
        }
    + Add eslint plugin to /worldwise/src/main.jsx
        import eslint from 'vite-plugin-eslint';
        export default defineConfig({
          plugins: [react(), eslint()],
        });

- Routing - match different URLs to different UI views (React components): routes
- This enables users to navigate between different Applications screens, using the browser URL
- Keeps the UI in sync with the current browser URL
- React Router is use as third-party libraries
- It allows us to create Single Page Application (SPA)

- Single-Page Application (SPA) is executed entirely on the client (browser)
- Routes: different URLs correspond to different views(components)
- JavaScript (React) is used to update the page (DOM)
- The page is never reloaded
- Feels like a native app
- Additional data might be loaded from web API
      user clicks router link ---> URL is changed ---> DOM is updated: React component corresponding to the new URL is rendered

- install react router package:
     npm i react-router-dom@6

- Define route example:
    const App = () => {
      return (
        <BrowserRouter>
          <Routes>
            <Route path="/" element={<Homepage />} />
            <Route path="product" element={<Product />} />
            <Route path="pricing" element={<Pricing />} />
            <Route path="*" element={<PageNotFound />} />
          </Routes>
        </BrowserRouter>
      );
    };

- use nav panel in component:
    const PageNav = () => {
      return (
        <nav>
          <ul>
            <li>
              <Link to="/">Home</Link>
            </li>
            <li>
              <Link to="/pricing">Pricing</Link>
            </li>
            <li>
              <Link to="/product">Product</Link>
            </li>
          </ul>
        </nav>
      );
    };
- Usage:
    const Product = () => {
      return (
        <div>
          <PageNav />
          <h1>Product</h1>
        </div>
      );
    };

- To mark selected item use "NavLink" instead of "Link". It adds class="active" to selected element and we can change it via CSS:
  const PageNav = () => {
    return (
      <nav>
        <ul>
          <li>
            <NavLink to="/">Home</NavLink>
          </li>
          <li>
            <NavLink to="/pricing">Pricing</NavLink>
          </li>
          <li>
            <NavLink to="/product">Product</NavLink>
          </li>
        </ul>
      </nav>
    );
  };

- Styling options in React:
    + Inline CSS (style props in JSX elements)
    + CSS or Sass file (external file - Entire app - globally)
    + CSS Modules (One external file per component)
    + Css in JS (External file or component file)
    + Utility-first CSS (JSX elements) - tailwindcss
    + Alternative to styling with CSS: UI libs like MUI, Chakra UI, Mantine etc.

- In module CSS you should use class not tag names(it will not work)
- Usage module CSS:
    + worldwise/src/components/PageNav.jsx
          import styles from './PageNav.module.css';
          const PageNav = () => {
            return (
              <nav className={styles.nav}>
              .....
    + worldwise/src/components/PageNav.module.css
          .nav {
            background-color: orangered;
          }

          .nav ul {
            list-style: none;
            display: flex;
            justify-content: space-between;
          }

- React create random class: class="_nav_2srth_1"
- To give some particular class styler need to use global:
      .nav :global(.active) {
        background-color: green;
      }

- Usage style class in different component can be with global function:
    + worldwise/src/components/PageNav.jsx
        :global(.test) {
          background-color: red;
        }
    + worldwise/src/pages/Homepage.jsx
        const Homepage = () => {
          return (
            <div>
              <PageNav />
              <AppNav />
              <h1 className='test'>WorldWise</h1>
              ...

- Snipet
    "importCSSModule": {
      "prefix": "csm",
      "scope": "javascript,typescript,javascriptreact",
      "body": ["import styles from './${TM_FILENAME_BASE}.module.css'"],
      "description": "Import CSS Module as `styles`"
    },

- Use nested Routing: like /app/cities (Outlet like childrent elements)
    const App = () => {
      return (
        <BrowserRouter>
          <Routes>
            <Route path="/" element={<Homepage />} />
              ....
            <Route path="app" element={<AppLayout />}>
              <Route index element={<p>LIST</p>} />             ---------  DEFAULTE
              <Route path="cities" element={<p>List of cities</p>} />
              <Route path="countries" element={<p>Countries</p>} />
              <Route path="form" element={<p>Form</p>} />
            </Route>
            ....

    const AppLayout = () => {
      return (
        <div className={styles.app}>
          <Sidebar />
          <Map />
          ....
    
    const Sidebar = () => {
      return (
        <div className={styles.sidebar}>
          <Logo />
          <AppNav />

          <Outlet />
          ....

- To link previous nested rout with web elements:
    const AppNav = () => {
      return (
        <nav className={nav}>
          <ul>
            <li>
              <NavLink to="cities">Cities</NavLink>
            </li>
            <li>
              <NavLink to="countries">Countries</NavLink>
            </li>
            ....

- the URL for state management:
  + The URL is an excelent place to store UI state and an alternative to useState in some situations!
    Examples: open/closed panels, currently selected list item, list sorting order, applied list filters

  1. Easy way to store in a "global place", accessible to all components in the app
  2. Good way to "pass" data from one page into the next page
  3. Makes it possible to "bookmark and share" the page with the exact UI state it had at the time

  www.example.com/app/cities/lisbon?lat=38.4343&lng=-9.743864
  /app/cities - path
  lisbon - parameters
  lat=38.4343&lng=-9.743864 - query string

  City name and GPS location were retrieved from the URL instead of application state!

- Create a route to open certain component when the link is matche the pattern
         <Route path="cities/:id" element={<City />} />
- Add link too component with the same pattern which will lead to previous component after click
          const CityItem = ({ city }) => {
            const { cityName, emoji, date, id } = city;
            return (
              <li>
                <Link className={styles.cityItem} to={`${id}`}>
                .....

- Then we can read param from URL using useParams hook
    function City() {
      const { id } = useParams();
      ...

- Set search params to URL
     <Link className={styles.cityItem} to={`${id}?lat=${position.lat}&lng=${position.lng}`}>

- Get Search params from URL
    const [searchParams, setSerchParams] = useSearchParams();
    const lat = searchParams.get('lat');
    const lng = searchParams.get('lng');

- Update search params in URL
      <button
        onClick={() => {
          setSerchParams({ lat: 23, lng: 50 });
        }}
      >
        Change pos
      </button>

- Imperitive way - useNavigate - navigate to another page without clicking any butto, for instance after submitting form:
    const Map = () => {
      const navigate = useNavigate();
      const [searchParams, setSerchParams] = useSearchParams();
      const lat = searchParams.get('lat');
      const lng = searchParams.get('lng');
      return (
        <div
          className={styles.mapContainer}
          onClick={() => {
            navigate('form');
          }}>
          ...

- navigate to previous page (-1)
        <Button
          type="back"
          onClick={(e) => {
            // prevent re-submit all form(re-rendering) because button inside the form
            e.preventDefault();
            // move to previous page
            navigate(-1);
          }}
        >
          &larr; Back
        </Button>

- Declaritive way. Usually is not used. It's used a s for home page to navigate to particular URL
        <Route path="app" element={<AppLayout />}>
          <Route index element={<Navigate replace to="cities" />} />
          <Route path="cities" element={<CityList cities={cities} isLoading={isLoading} />} />
          ....

*****************************************************************************************************************
Section 18: Advanced State Management: The Context API
*****************************************************************************************************************

- PROJECT: 12-atomic-blog/atomic-blog

- A prop drilling. Sollutions:
    1. Passing props through all level into deeply nested components (BAD SOLUTION)
    2. Context API. Read state everywhere (GOOD SOLUTION)

- Context API:
    + System to pass data throughout the app withiut manually passing props down the tree
    + Allows us to "broadcast" global state to the entire app

    1. Provider: gives all child components access to value
    2. value: data that we want to make available (usually state and functions)
    3. Consumers: all components that read the provided context value

    value is updated -> all consumers re-render

- Flow:
    1. Create a new context
       const PostContext = createContext();
    2. Provide value to the child component
        <PostContext.Provider
          value={{
            posts: searchedPosts,
            onAddPost: handleAddPost,
            onClearPosts: handleClearPosts,
            searchQuery,
            setSearchQuery,
          }}
        >
          <section>
            <button
              onClick={() => setIsFakeDark((isFakeDark) => !isFakeDark)}
              className="btn-fake-dark-mode"
            >
              {isFakeDark ? '‚òÄÔ∏è' : 'üåô'}
            </button>

            <Header
              posts={searchedPosts}
              onClearPosts={handleClearPosts}
              searchQuery={searchQuery}
              setSearchQuery={setSearchQuery}
            />
            <Main posts={searchedPosts} onAddPost={handleAddPost} />
            <Archive onAddPost={handleAddPost} />
            <Footer />
          </section>
        </PostContext.Provider>
    3. Consuming context value
      function Header() {
        const { onClearPosts } = useContext(PostContext);
        return (
          <header>
            <h1>
              <span>‚öõÔ∏è</span>The Atomic Blog
            </h1>
            <div>
              <Results />
              <SearchPosts />
              <button onClick={onClearPosts}>Clear posts</button>
            </div>
          </header>
        );
      }

- 1. Better to use API Context as a Component:
    function PostProvider({ children }) {
      ....
        return (
        // 2. Provide value to the child component
        <PostContext.Provider
          value={{
            posts: searchedPosts,
            onAddPost: handleAddPost,
            onClearPosts: handleClearPosts,
            searchQuery,
            setSearchQuery,
          }}
        >
          {children}
        </PostContext.Provider>
      );
    function usePosts() {
      const context = useContext(PostContext);
      if (context === undefined) throw new Error('PostContext was used outside of the PostProvider');
      return context;
    }
    export { PostProvider, usePosts };

- 2. Usage
      <PostProvider>
        <Header />
        <Main />
        <Archive />
        <Footer />
      </PostProvider>
      -------
    // 3. Consuming context value
    const { onClearPosts } = usePosts();

- Types of State:
    1. State Accessibility: 
        + Local State   - Need only by one or few components
                        - Only accessible in component and child
                        - If your component was rendered twice, should a state update in one of them reflected one? - NO

        + Global State  - Might be needed by many components
                        - Accessible to every component in the application
                        - If your component was rendered twice, should a state update in one of them reflected one? - YES

    2. State Domain:
        + Remote State  - All application data loaded from a remote server (API)
                        - Usually asynchronously
                        - Needs re-fetching + updating
        + UI State      - Everything else :)
                        - Theme, list filters, from data, etc.
                        - Usually synchronous and stored in the application

- State placement option:
    + Local component   - Tools: useState, useReducer or useRef
                        - When: Local state
    + Parent component  - Tools: useState, useReducer or useRef
                        - When: Lifting up state
    + Context           - Tools: Context API + useState or useReducer
                        - When: Global state (Preferably UI state)
    + 3rd-party library - Tools: Redux, React Query, SWR, Zustand, etc.
                        - When: Global state (remote or UI)
    + URL               - Tools: React Router
                        - When: Global State, passing between pages
    + Browser           - Tools: Local storage, session storage, etc
                        - When: Storing data in user's browser

- To ommit redirecting to login page after Log In clicking 'Back' button in btowser use:
    useEffect(
      function () {
        if (isAuthenticated) navigate('/app', { replace: true });
      },
      [isAuthenticated, navigate],
    );

- Redirect to root if not authenticated. Created own componet and call it in App.jsx
        const ProtectedRoute = ({ children }) => {
          const { isAuthenticated } = useAuth();
          const navigate = useNavigate();
          useEffect(
            function () {
              if (!isAuthenticated) navigate('/');
            },
            [isAuthenticated, navigate],
          );

          return isAuthenticated ? children : null;
        };
        ........
                    <Route path="login" element={<Login />} />
            <Route
              path="app"
              element={
                <ProtectedRoute>
                  <AppLayout />
                </ProtectedRoute>
              }
            >
              <Route index element={<Navigate replace to="cities" />} />
              .....

*****************************************************************************************************************
Section 19: Performance Optimization and Advanced useEffect
*****************************************************************************************************************

- performance Optimization Tools
  1. prevent wasted renders
    + memory
    + useMemo
    + useCallback
    + passing elements as children or regular prop
  2. improve app speed/responsiveness
    + memory
    + useMemo
    + useCallback
  3. reduce bundle size
    + using fewer 3rd-party packages
    + code splitting and lazy loading

- When does a component instance re-render:
    + state changes
    + context changes
    + parent re-renders (creates the false impression that changing props re-renders a component. This is NOT true)

- Remember: a render does not mean that the DOM actuallyu gets updated, it just means the component functiongets called. But this can be expensive operation.
- Wasted render: a render that didn't produce any changes in DOM
- Only a problem when they happen too frequently or when the component is very slow

- For debug. Use Dev Tools plugin React(Components and Profiler) -> Profiler
- Set up it: Settings -> "Record why each component rendered while profiling"=True
- Record and change state

- Trick optimization with children props (React just creates slow component before passing into component as child):
  + Slow
    function SlowComponent() {
      // If this is too slow on your maching, reduce the `length`
      const words = Array.from({ length: 100_000 }, () => 'WORD');
      return (
        <ul>
          {words.map((word, i) => (
            <li key={i}>
              {i}: {word}
            </li>
          ))}
        </ul>
      );
    }
    export default function Test() {
      const [count, setCount] = useState(0);
      return (
        <div>
          <h1>Slow counter?!?</h1>
          <button onClick={() => setCount((c) => c + 1)}>Increase: {count}</button>
          <SlowComponent />
        </div>
      );
    }

  + Fast:
    function Counter({ children }) {
      const [count, setCount] = useState(0);
      return (
        <div>
          <h1>Slow counter?!?</h1>
          <button onClick={() => setCount((c) => c + 1)}>Increase: {count}</button>
          {children}
        </div>
      );
    }

    export default function Test() {
      return (
        <div>
          <h1>Slow counter?!?</h1>
          <Counter>
            <SlowComponent />
          </Counter>
        </div>
      );
    }

- Memoization - optimization technique that executes a pure function once, and saves the result in memory. 
  If we try to execute the function again with the same arguments as before, previous saved will be returned, 
  without executing the function again.
    + Momoize components with memory
    + Memoize objects with use 
    + MemoMemoize functions with useCallback
  1. Prevent wasted renders
  2. Improve app speed/resposivnes

- Memoized component - not render if its parent re-render as long as props stay the same beween renders
- Only affects props! A memorized component will still re-render when its own state changes or when a context that it's subscribed to changes
- Only makes sence when the component is heavy (slow rendering), re-renders often, and does so with the same props

- Add component to memo, just wrap by memo function:
    const Archive = memo(function Archive({ show }) {
      ......

- useMemo - memorize values between renders
- useCallback - memorize function between renders
- values passed into useMemo and use Callback will be stored in memory ('cached') and returned in subsequent re-renders, as long as dependencies ('inputs') stay the same
- useMemo and useCallback have a dependency array (like useEffect): whenever one dependency changes, the value will be re-created

Three big uses cases:
1. Memoizing props to prevent wasted renders (together with memo)
2. Memoizing values to avoid expensive re-calculations on every render
3. Memoizing values that are used in dependancy array of another hook

- Example useMemo: 
  const archiveOptions = useMemo(() => {
    return {
      show: false,
      title: 'Post archive in addition to main posts',
    };
  }, []);

  const archiveOptions = useMemo(() => {
    return {
      show: false,
      title: `Post archive in addition to ${posts.length} main posts`,
    };
  }, [posts.length]);

  - Example useCallback:
  const handleAddPost = useCallback(function handleAddPost(post) {
    setPosts((posts) => [post, ...posts]);
  }, []);

- Optimize context (only if all 3 are true):
    1. State in the context needs to change all the time
    2. Context has many consumers
    3. App is slow and laggy
    
- Bundle and code splitting
    + Bundle - JS file containing the entire application code. Downloading the bundle will load the entire app at once, turning it into a SPA
        - Vite
        - Webpack (inside create-react-app)
    + Bundle Size - amount of JS users have to download to start using app. One of the most important things to be optimized, so that the bundle takes less time to download.
    + Code splitting - splitting bundle into multiple parts that can be downloaded over time ("lazy loading")

- Example of lazy load in App.js:
  // import Homepage from './pages/Homepage';
  const Homepage = lazy(() => import('./pages/Homepage'));

- Add Suspense API for lazy load with falback attribute (to display spinner meanwhile):
  const App = () => {
  return (
    <AuthProvider>
      <CitiesProvider>
        <BrowserRouter>
          <Suspense fallback={<SpinnerFullPage />}>  
            <Routes>
              <Route index element={<Homepage />} />
              <Route path="product" element={<Product />} />

- Don't optimize prematuraly:
    + find performance bottleneck using Profile and visual inspection (laggy UI)
    + Fix those real performance issues
    + Memoize expensive re-renders
    + Memoize expensive calculations
    + Optimize context if it has many consumers and changes often
    + Memoize context value + child components
    + Implement code splitting + lazy loading for SPA routes

- useEffect dependency array rules:
    + Every state variable, prop and context value used inside the effect MUST be included in the dependency array
    + All "reactive values" must be included! That means any function or variable that reference any other reactive values
    + Dependencies choose themselves: NEVER ignore the exhaustive-deps ESLint rule!
    + Do NOT use objects or arrays as dependencies (objects are reacted on each render and React sees new objects as different, {} !== {})

- Removing unnecessary dependencies:
    + Removing function dependencies:
        - Move function into the effect
        - if you need the function in multiple place, memoize it (useCallback)
        - if the function doesn't reference any reactive values, move it out of the component
    + Removing object dependencies:
        - Instead of including the entire object, include only the properties you need (primitive values)
        - if that doesn't work, use the same strategies as for functions (moving or memoizing object)
    + Other strategies
        - if you have multiple related reactive values as dependencies, try using a reducer (useReducer)
        - you don't need to include setState (from useState) and dispatch (from useReducer) in the dependencies, as React guarantees them to be stable across renders

- When NOT to use an effect
    + Effects should be used as a last resort, when no other solution makes sense. React calls them an 'escape hatch' to step outside of React

- Three cases where effects are overused:
    1. Responding to a user event. An event handler function should be used instead
    2. Fetching data on component mount. This is fine in small apps, but in real-world app, a library like React Query should be used
    3. Synchronizing state changes with one another (setting state based on another state variable). Try to use derived state and event handlers

- Stale closure - when fuction was created initialy and point to init 'snapshot' of 'number' var (outdated value)
  useEffect(function() {
    document.title = `Your ${number}-exercise workout`
  }, [])

- Re-execute function, just use dependany array 
  useEffect(function() {
    document.title = `Your ${number}-exercise workout`
  }, [number])

*****************************************************************************************************************
Section 20: Redux and Modern Redux Toolkit (With Thunks)
*****************************************************************************************************************

- Redux:
    + 3rd-party lib to manage global state
    + Standalone lib, but easy to integrate with React apps using react-redux lib
    + All global state is stored in one globaly accessible store, which is easy to update using "actions" (like useReducer)
    + It's conceptually similar to using the Contex API + useReducer
    + Two "versions": (1) Classic Redux, (2) Modern Redux Toolkit

- Global store is updated -> All consuming components re-render

- Historically Redux was used in most Reacts apps for all global stae. Today that has changed, necause there are many alternatives. Many apps don't need a lot of global UI state.
    + UI Local State: useState, useReducer, useRef
    + UI Global State: Context API + useState/useReducer; Redux, Zustand, Recoil, etc; React Router
    + Remote Local State: fetch + useEffect + useState/useReducer
    + Remote Global State: Context API + useState/useReducer; Redux, Zustand, Recoil, etc; React Query; SWR; RTK Query

- Mechanism of the useReducer hook:
    + Event handler in component(action with type and payload) -> dispatch -> reducer(current state) -> Next state -> Re-render\

- Mechanism of the Redux hook:
    + Event handler in component -> Action creator function(auto create action with type and payload) -> dispatch -> STORE with multiple reducers(current state) -> Next state -> Re-render
    
- Setup redux project:
    + npx create-react-app@5 redux-intro
    + npm i redux
- Example as a beggining: 
      import { createStore } from 'redux';
      const initialState = {
        balance: 0,
        loan: 0,
        loanPurpose: '',
      };
      function reducer(state = initialState, action) {
        switch (action.type) {
          case 'account/deposit':
            return { ...state, balance: state.balance + action.payload };
          case 'account/withdraw':
            return { ...state, balance: state.balance - action.payload };
          case 'account/requestLoan':
            if (state.loan > 0) return state;
            // later
            return {
              ...state,
              loan: action.payload.amount,
              loanPurpose: action.payload.purpose,
              balance: state.balance + action.payload.amount,
            };
          case 'account/payloan':
            return { ...state, loan: 0, loanPurpose: '', balance: state.balance - state.loan };
          default:
            return state;
        }
      }
      const store = createStore(reducer);
      store.dispatch({ type: 'account/deposit', payload: 500 });

- combine 2 reducers:
    const rootReducer = combineReducers({ account: accountReducer, customer: customerReducer });
    const store = createStore(rootReducer);

- Provider for stor to components:
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(
        <React.StrictMode>
          <Provider store={store}>
            <App />
          </Provider>
        </React.StrictMode>,
      );

- Get state from store in components:
    import { useSelector } from 'react-redux';
    function Customer() {
      const customer = useSelector((store) => store.customer.fullName);
      console.log(customer);

- Dispatching Actions from Our React App:
  const dispatch = useDispatch();
  function handleClick() {
    if (!fullName || !nationalId) return;
    dispatch(createCustomer(fullName, nationalId));
  }

- The Legacy Way of Connecting Components to Redux. Old way to use 'balance' value from state in component:
    function mapStateToProps(state) {
      return {
        balance: state.account.balance,
      };
    }
    export default connect(mapStateToProps)(BalanceDisplay);

- Redux Middleware and Thunks. 
  What is Redux Middleware?
  'COMPONENT' --> 'dispatch' --> 'MIDDLEWARE' --> 'STORE'
  Middleware - functions that sits between dispatching the actions and store:
    + perfect for async code
    + API calls, timers, logging
    + The place for side effects
  Redux Thunks - 3rd-party lib for middleware

- Making an API Call With Redux Thunks
  npm i redux-thunk
  const store = createStore(rootReducer, applyMiddleware(thunk));
  If we return in action function, redux will know that it's async (middleware) 
    export function deposit(amount, currency) {
      if (currency === 'USD') return { type: 'account/deposit', payload: amount };
      return async function (dispatch, getState) {
        dispatch({ type: 'account/convertingCurrency' });
        const res = await fetch(
          `https://api.frankfurter.app/latest?amount=${amount}&from=${currency}&to=USD`,
        );
        const data = await res.json();
        const converted = data.rates.USD;
        console.log(converted);
        dispatch({ type: 'account/deposit', payload: converted });
      };
    }