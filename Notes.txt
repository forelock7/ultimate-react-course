*****************************************************************************************************************
Section 3: A First Look at React
*****************************************************************************************************************

- Vanila JS - pure JS without any framework, but can be Jquery

- Vanila JS vs React: https://codesandbox.io/s/react-first-app-advice-52879f

- React - JS library for building user interfaces. 
1) Based on components - combining blocks of complex UI
2) Declarative 
 + describe how components look like and how they work using a declarative syntax called JSX.  
 + Declarative telling React what a component shoulld look like, based on current data/State
 + React is abstraction away from DOM: we never touch the DOM(like vanilla JS)
 + JSX: a syntax that combines HTML, CSS, JS as well as referencing other components.
3) State-driven: REACT reacts to state changes by re-rendering the UI. State -> Render -> UI(Component written with JSX) -> Action on UI -> Update state -> Re-render -> UI
4) JS library - React is just library (not framework), because it's only the 'view' layer. We need to pick multiple external libraries to build a comlete application. Complite frameworks built on top of React - NEXT.js, Remix
5) Extremely popular - a lot of companies use React
6) Created by facebook in 2011 by Jordan Walke

- Two option for setting up a project
1) create-react-app (complete 'starter kit', ESLint, Prettier, Jest etc) - slow and outdated technologies. It's used for small projects.
2) VITE - modern too. Need to manually set up ESLint. Extrimaly fast host replacement (HMR) and bundling. It's used for real projects

- NEXT.js and Remix framework provide more functionality than Vanila React by itself.

- Create React project from scratch using 'create-react-app' 
npx create-react-app@5 pizza-menu

- To run JS/TS inside VScode use 'Quokka.js' extansios

*****************************************************************************************************************
Section 5: Working With Components, Props, and JSX
*****************************************************************************************************************

- Start React project 
npm run start

- React apps are entirely made out of components
- building blocks of user inerfaces in React
- Piece of UI that has its own 'data', 'logic' and 'appearance' (how it works and looks)
- We build complex UIs by building multiple components and combining them
- Components can be reused, nested inside each other and pass data between them

- Component tree - to understand the structure (Parent and child components)

- Rules for functions of components:
1) function name must start with capital letter 
2) function must return murkup (html)
3) Each component can return only one element (correct: <div><h1>Bla</h1><h2>Bla</h2></div>, wrong: <h1>Bla</h1><h2>Bla</h2>)
4) Never nest component function in component function

- Component:
+ data
+ logic
+ appearance

- JSX:
  + Declarative syntax to describe what components look like and how they work
  + Components must return a block of JSX
  + Extension of JS that allows us to embed following elements into HTML:
    1) JS
    2) CSS
    3) React Components

- BABEL in React convert HTML with JSX into JS. (you can use just JS functions instead of JSX syntax)

- Imperative approach - "How to do this" - create elements via Vanila JS 
   + Manual DOM element selections and DOM traversing.
   + Step-by-Step DOM mutation until we reach the desired UI
- Declarative approach - "What we want"
   + Describe what UI should look like using JSX, based on current data
   + React is an abstraction away from DOM: we never touch the DOM
   + Instead, we think of the UI as a reflection of the current data

- alert can happen twice because of 'strict' mode 

- One technology per file (traditional)
- One component per file (React new paradigm)

- Use JS code in JSX syntax - just cover with {}
        <p>{props.ingredient}</p>

- props in React: if you need use something except string - use JS mode {}
      <Pizza
        name="Pizza Spinaci"
        ingredient="Tomato, mozarella, spinach, and ricotta cheese"
        photoName="pizzas/spinaci.jpg"
        price={10}
      />

- Props are used to pass data from parent to child component

- Props are read-only, they are immutable. This is one of React's strict Rules

- If you need to mutate props, you actually need state

- One-way Data Flow - Data can pass only from parent top child!!! (Angular has two-way data flow)
    + more predictable
    + easier to debug
    + more performant

- Challenge #1: https://codesandbox.io/s/profile-card-v1-2hrm4p?file=/src/index.js

- In JS mode {} you can place JS expression (reference vars, create arrays or objects, [].map, ternary operator)
- In JS mode statements are not allowed (if/else, for, switch)
- JSX can be written anywhere inside components (in if/else, assign to vars, pass it into functions)
- Piece of JSX can only have one root element. If you need more, use <Raact.Fragment> (or the short <>)

- If we use iteration in React, you should use 'key' unique property to avoid console log errors
function Menu() {
  return (
    <main className="menu">
      <h2>Our menu</h2>

      <div>
        {pizzaData.map((pizza) => (
          <Pizza pizzaObj={pizza} key={pizza.name} />
        ))}
      </div>
    </main>
  );
}

- Shortcircuting in React. Use only boolean value (NOT truthy or falsy value), because boolean values are not returned:
      {numPizzas > 0 && (
        <ul className="pizzas">
          {pizzas.map((pizza) => (
            <Pizza pizzaObj={pizza} key={pizza.name} />
          ))}
        </ul>
      )}

- In LS mode we can use if/else statement or any other JS code, except code that produce some value

- common technic to return 'null'
function Pizza(props) {
  if (props.pizzaObj.soldOut) return null;
  return (
    <li className="pizza">
      <img src={props.pizzaObj.photoName} alt={props.pizzaObj.name} />
      <div>
        <h3>{props.pizzaObj.name}</h3>
        <p>{props.pizzaObj.ingredients}</p>
        <span>{props.pizzaObj.price}</span>
      </div>
    </li>
  );
}

- props can be destructuring
function Pizza(props)
function Pizza({ pizzaObj })

- React fragment - use if you need to combane 2 elements without wrappimg them into another one
        <>
          <p>
            Authentic Italian cuisine. 6 creative dishes to choose from. All from our stone oven,
            all organic, all delicious.
          </p>
          <ul className="pizzas">
            {pizzas.map((pizza) => (
              <Pizza pizzaObj={pizza} key={pizza.name} />
            ))}
          </ul>
        </>

- if you need add some key to React fragment, just use following fragment
<React.Fragment key={ghdsghd}>
.....
</ React.Fragment>

- three options in JSX
      <span>
        {level === "advanced" && "üí™"}
        {level === "intermediate" && "üëç"}
        {level === "begginer" && "üê£"}
      </span>

*****************************************************************************************************************
Section 6: State, Events, and Forms: Interactive Components
*****************************************************************************************************************

- Set style for element
        <button style={{ backgroundColor: '#7950f2', color: '#fff' }}>Previous</button>

- Set click event for element ('onClick')
<button style={{ backgroundColor: '#7950f2', color: '#fff' }} onClick={() => alert('Next')}>

- Alert Function immidiatly run (NOT valid for this case)
<button onClick={alert('Next')}>

- Mouse handler
onMouseEnter={() => alert('TEST')}

- Another way to define handler function
  ........
  function handlePrevious() {
    alert('Previous');
  }
  return (
    ........
        <button style={{ backgroundColor: '#7950f2', color: '#fff' }} onClick={handlePrevious}>
    ........

- State - data that a component can hold over time, necessary for information that it needs to remember throughout the app's lifecucle
- "Component's memory"
- Component state - single local component variable ("Piece of state", "State variable")
- Updating component state triggers React to re-render the component

- Component View - when component is rendered

- State allows:
    1) Upfate the component's view (by re-rendering)
    2) Persist local variables between renders

- Use state in code, where 'step' - variable, 'setStep' - function to update state, 'useState' - function to create a state with init value
  const [step, setStep] = useState(1);
  function handlePrevious() {
    if (step > 1) setStep(step - 1);
  }

- Do NOT update state like this:
step = step + 1

- Update State -> Re-render component -> View
- In React, a view is updated by re-rendering the component
- A component is re-rendered when its state is updated
- DATA <-> UI

- Use ONLY callback function to update State
    if (step < 3) setStep((s) => s + 1);
    // BAD PRACTICE:
    if (step < 3) setStep(step + 1);

- UI as a function of state. UI as a reflection of data changing pver time

- For data that should not trigger re-rendering UI do not use state

- Prevent default action when submit form
function Form() {
  function handleSubmit(e) {
    e.preventDefault();
  }
  return (
    <form className="add-form" onSubmit={handleSubmit}>
    .....

- State 
  + internal data, owned by component
  + Component "memory"
  + Can be updated by component itself
  + Updating state causes component to re-render
  + Used to make components interactive

- Props:
  + External data, owned by parent component
  + Similar to function parameters
  + Read-only
  + Receiving new props causes component to re-render. Usually when the parent's state has been updated
  + Used by parent to configure child component ("settings")

  - https://codesandbox.io/s/react-exercise-flashcards-starter-sx254w?file=/src/App.js
  - https://codesandbox.io/s/date-counter-v2-d23kg4?file=/src/App.js

*****************************************************************************************************************
Section 7: Thinking In React: State Management
*****************************************************************************************************************

- The "Thinking in React" process:
  1. Break the desired UI into components and estabish the component tree
  2. Build a static version in React (without state)
  3. Think about state:                                       |
    + When to use state                                       |
    + Types of state: local vs global                         |
    + Where to place each piece of state                      | State managment
  4. Establish data flow:                                     |  
    + One-way data flow                                       |
    + Child-to-parent communication                           |
    + Accessing global state                                  |

- Local State - only for one or few components, child components
- Global State - many components. Shared state that accessible to every component in the entire applicatio. (by React Context API, Redux). Use firstly local state!!!!

- Pass function as props:
      export default function App() {
        ....
        function handleAddItems(item) {
          setItems((items) => [...items, item]);
        }
        return (
          <div className="app">
            ....
            <Form onAddItems={handleAddItems} />
            ....
          </div>
        );
      }
      function Form({ onAddItems }) {
          ......
          onAddItems(newItem);
          ......
        }

- "Lifting Up State" - just moving state of component to parent component if you need access to state of several sibling component. 
Child-to parent communication (inverse data flow): child updating parent state (data "flowing" up). Use set function of state in child to update state.

- Derived state(–ø–æ—Ö—ñ–¥–Ω–∏–π) - state that is computed from an existing piece of state or from props
Do not need to devide state of object to several states of elements of that object. Just use regular vars, no useState. State of object is the single state of thruth for related data.

- Sort items in alphabetical order
if (sortBy === 'description') sortedItems = items.slice().sort((a, b) => a.description.localeCompare(b.description));

- Sort by boolean and number:
  if (sortBy === 'packed') sortedItems = items.slice().sort((a, b) => Number(a.packed) - Number(b.packed));

  - 'children' Props
  props.children
  Example:
            <Button textColor="#fff" bgColor="#7950f2" onClick={handlePrevious}>
              <span>üëà</span> Previous
            </Button>
            ......
            function Button({ textColor, bgColor, onClick, children }) {
              return (
                <button style={{ backgroundColor: bgColor, color: textColor }} onClick={onClick}>
                  {children}
                </button>
              );
            }

- Work with current state inside setState method
    const [selectedFriend, setSelectedFriend] = useState(null);
    function handleSelection(friend) {
      setSelectedFriend((cur) => (cur?.id === friend.id ? null : friend));
    }

*****************************************************************************************************************
Section 10: Thinking in React: Components, Composition, and Reusability
*****************************************************************************************************************

- Split a UI into component:
  1) Logical separation of content/layout
  2) Reusability
  3) Resposibility / complexity
  4) Personal coding style

- Start from building big component and then split it if necessary

- Categories of Components:
  1) Stateless / presentational components - no state, can receive props and simply present received data or other content, usually small and reusable
  2) Stateful components - have state, can still be reusable
  3) Structural components - pages/layouts/screens of app, result of composition, can be huge and non-reusable(but don't have to)

- Component Composition:
1.
  function Model() {
    return (
      <div>
        <Success />
      </div>
    )
  }
2. - makes component reusable!!!!!
  function Model({ children }) {
    return (
      <div>
        {children}
      </div>
    )
  }

- Passing Elements as props
    <Box element={<Movie />} />
  instead of 
    <Box>
      <Movie />
    </Bob>

- Props as an API of component - try to have balance of props, their number should be enough, but not too many
    <StarRating maxRating={5} messages={['Terrible', 'Bad', 'Okay', 'Good', 'Amazing']} />
    <StarRating maxRating={5} color="red" className="test" defaultRating={3} />
    ......
    export default function StarRating({
      maxRating = 5,
      color = '#fcc419',
      size = 48,
      className = '',
      messages = [],
      defaultRating = 0,
    }) 

- Validation of props type. This approach is outdated. Now just use TypeScript
    import PropTypes from 'prop-types';
    StarRating.propTypes = {
      maxRating: PropTypes.number,
      defaultRating: PropTypes.number,
      color: PropTypes.string,
      size: PropTypes.number,
      messages: PropTypes.array,
      className: PropTypes.string,
      onSetRating: PropTypes.func,
    };

*****************************************************************************************************************
Section 11: How React Works Behind the Scenes
*****************************************************************************************************************

- Component -> Component Instance -> React Element -> DOM Element (HTML)

- How components are displayed on the screen:
  1. Trigger (Render is triggered (Updating State))
  2. Render Phase (React calls component funcs and figures out how DOM should be updated) - it's quite different than rendering UI
  3. Commit Phase (React actually writes to the DOM, updating, inserting and deleting elements)
  4. Browser paint

- The render process is triggered for the enire application
- In practice, it looks like React only re-render the component where the state update happens, but that's not how it works behind the Scenes
- Renders are not triggered immediately, but scheduled for when the JS engine has some "free time". There is also batching of multiple setState calls in event handlers

- Rendering in React is calling component function, not updating screen/DOM
- Virtual DOM - React element(component) tree
- Rendering a component will cause all of its child components to be rendered as well (no matter if props changed or not). Necessary because React doesn't know whether children will be affacted
- Reconciliation - deciding which DOM elements actually need to be inserted, deleted or updated in order to reflect the latest state changes.
- Reconciler - engine of React. It allows us never touch DOM directly, instead tells the React how next snapshot of UI should look like.
- Fiber is current reconciler of React. It takes React element tree (virtual DOM) and builds Fiber Tree based on it.
- Fiber tree - internal tree that has a 'fiber' for each component instance and DOM element. Fibers are NOT re-create on every render, it's mutable!
- Work can be done asynchronously - Rendering process can be split into chunks, tasks can be prioritized and work can be paused, reused or thrown away. Enables concurrent features like Suspense or transitions. Long renders won't block JS engine
- After updating of Virtual DOM executes Reconciliation + Diffing - compering current fiber tree with new Virtual DOM and updating Fiber Tree (build workInProgress tree) 
- List of effects (List of DOM updates) - result of Render Phase

- Commit Phase - updating DOM based on "List of DOM updates"
- Committing is synchronous: DOM is updated in one go, it can't be interrupted.

- After the Commit phase completes, the workInProgress fiber tree becomes the current tree for the next cycle
- Browser paint - is next after Commit phase - updated UI on the sceen.

1. Trigger (change state)
2. Render Phase - is performed by 'React' (never touch the DOM)
3. Commit Phase - is performed by 'ReactDOM'(browsers), 'React Native' (IOS, android), 'Remotion' (video) etc.
4. Browser Paint - is performed by browser (or IOS, android, video etc)

- Diffing uses 2 fundamental assumption (rules):
  1. Two elements of different types will produce different trees
  2. Elements with a stable key prop stay the same across renders

- Two situation:
  1. Same position, DIFFERENT element:
    + React assumes entire sub-tree is no longer valid
    + Old components are destroyed and removed from DOM, including state
    + Tree might be rebuild if children the same (state is reset)
  2. Same position, SAME elements, but some props are changed:
    + Element will be kept (as well as child elements), including state
    + New props / attributes are passed if they changed between renders
    + Sometimes this is not what we want... Then we can use the key prop

- Key Prop - special that we use to tell the diffing algorithm that an element is unique
  + Allows React to distinguish between multiple instances of the same component type
  + When a key stays the same across renders, the element will be kept in the DOM (even if the position in the tree changes)
    1. Using keys in List
  + When a key changes between renders, the element will be destroyed and a new one will be created (even if the position in the tree is the same as before)
    2. Using key to reset state

- Types of logic in React components
  1. Render logic
    + top level of the component function
    + describes how component view looks like
    + execute every time the component renders
  2. Event handler functions
    + executed as a consequence of the event that the handler is listening for
    + code that actually update state, perform an HTTP requests, read an input field, navigate to another pages

- Functional programming principales:
  + Side effect: dependancy on or modification of any data outside the function scope. Interaction with the outside world(mutating external vars, HTTP requests, writing DOM)
      const areas = {};
      function circleArea(r) {
        areas.circle = 3.14 * r * r;
      }
  + Pure function: has no side effects. Does not change any vars outside its scope. Give the same input, a pure function always returns the same output
      function circleArea(r) {
        return 3.14 * r * r;
      }
  + Inpure function (first function is also inpure):
      function circleArea(r) {
        const date = Date.now();       <---------
        const area = 3.14 * r * r;
        return `${date}: ${area}`
      }

- Rules for Render logic"
  + Components must be pure when it comes to render logic: given the same props(input), a component instance should always return the same JSX (output)
  + Render logic must produce no side effects: no interactions with 'outside world' is allowed:
    * Do NOT perform network requests (API calls)
    * Do NOT start timers
    * Do NOT directly use the DOM API
    * Do NOT mutate objects or vars outside the function scope
    * Do NOT update state (or refs): this will create an infinite localeCompare
- Side effects are allowed (and encouraged) in event handler functions. There is special hook to register side effects (useEffect)

- How State updates are batched:
  const reset = function() {
    setAnswer('');
    console.log(answer);
    setBest(true);
    setSolved(false);
  }
- React will update all 3 states together and then render and commit. So answer !== ''.
- If we need update state based on previous update, use setState with callback:
    console.log(setAnswer(answer => ...));

- React 18+ supports not only 'Event Handlers' as React 17, but also:
  + Timeouts
  + Promises
  + Native Events

  - Use callback function to update state and use it again in the same function
    function handleTripleInc() {
      // setLikes(likes + 1); // 1
      // setLikes(likes + 1); // 1
      // setLikes(likes + 1);  // 1
      setLikes((likes) => likes + 1); // 1
      setLikes((likes) => likes + 1); // 2
      setLikes((likes) => likes + 1); // 3
    }

- Event propagation in the browser
1. New Event object created in the root element, 'html', and travels to the target, where event was triggered, for instance 'button' (Capturing phase)
2. Then Event object travels to root back (Bubling phase)
- By default event handlers listen to events on the target and during the building phase
- We can prevent bubbling with 
    e.stopPropagation();

- Event delegation:
  + Handling events for multiple elements centrally in one single parent element
  + Better for performance and memory, as it needs only one handler function:
      1. Add handler to parent (.options)
      2. Check for target element (e.target)
      3. If target is one of the <button>s, handle the event
- It's very common for vanilla JS apps, but not so much in React

- React registers all event handlers on the root DOM container. This is where all events are handled.
- Behind the scenes, React performs event delegation for all events in our application

- React uses SyntheticEvent - is wrapper around DOMs native event object (PointerEvent, MouseEvent, KeyboardEvent...)
- It has the same interface as native event objects, like stopPropagation() and preventDefault()
- Fixes browser inconsistencies, so that events work in the exect same way in all browsers
- Most synthetic events bubbles (including focus, blur and change), except scroll

- Difference of events in React from vanila JS:
    1. Attributes for event handlers are named using camelCase (onClick instead of onclick or click)
    2. Default behavior can NOT be prevented by returning false (only by using preventDefault())
    3. Attach 'Capture' if you need to handle during capture phase (example: onClickCapture)

- Library vs Framework: React is library!
- Framework - includes all you need. Like Angular: HTTP request, Styling, Routing, Form Management
- Library - just used for particular part. React - just for view, except React you also need to use other 3rd-party libraries for HTTP request, Styling, Routing, Form Management

- React 3rd party library ECOSYSTEM:
  1. Routing (for SPAs): React Router, React Location
  2. HTTP requests: JS fetch(), Axios
  3. Remote state management: React Query, SWR, Apollo
  4. Global state management: Context API, Redux, Zustand
  5. Styling: CSS Modules, Styled components, tailwindcss
  6. Form management: React Hiik Form, FORMIK
  7. Animations/transitions: Motion, React-spring
  8. UI components: Mi, chakra, Mantime

- Opinionated React frameworks: Next.js, Remix, Gatsby. It's alternative for first approach

- Summary
  - Component - is like blueprint for a piece of UI. React creates a component instance. When a component instance is rendered, it will return React element
  - Rendering - calls component functions and calculating what DOM elements need to be updated/ Each time a component instance is rendered or re-rendered, the function is called again
  - Only the initial app render and state updates can cause a render, which happens for the entire app
  - When a component instance gets re-rendered, all its children will get re-render as well. This doesn't mean that all children willget updated in the DOM, thanks reconciliation, 
    which checks which element actually changed between two renders. But all this re-rendering can still have impact on performance (more on that later in the cource)
  - Diffing is how decided which DOM elements need to be added or modified.
  - Giving elements a key prop allows React to avoid destroying elements or reset state
  - Never declare a new component inside another component
  - The logic that produces JSX output for a component instance ("render logic") is not allowed to produce any side effects: no API calls, no timers, no object or variable mutations, no state updates. 
    Side effects are allowed in event handlers and useEffect
  - The DOM is updated in the commit phase, but not by React, but by a "rendered" called ReactDOM
  - Multiple state updates inside the handler function are batched, so it happens only one re-render.
  - Synthetic event object
  - React is a library, not a framework.

*****************************************************************************************************************
Section 12: Effects and Data Fetching
*****************************************************************************************************************

- REPO: 07-usepopcorn/usepopcorn

- Component lifecycle:
    1. Mount / Initial render
        + Component instance is rendered for the first time
        + Fresh state and props are created
    2. Re-render 
        + State changes
        + Props change
        + Parent re-render
        + Context changes
    3. Unmount
        + Component instance is destroyed and removed
        + State and props are destroyed

- Side effect is basically any "interaction between a React component and the world outside the component". 
Also when code that actually does something: data fetching, setting up subscriptions, setting up timers, manually accessing the DOM

- Side effects:
  + Event handlers - prefered way of using side effect function
  + EFFECTS (useEffect) - allows us to write code that will run at different moments: mount, re-render or Unmount

  useEffect(function () {
    fetch(`http://www.omdbapi.com/?apikey=${KEY}&s=interstellar`)
      .then((res) => res.json())
      .then((data) => {
        setMovies(data.Search);
      });
      return () => console.log('Cleanup') // Cleanup function
  }, []); // [] - Dependancy array

- Using async function instead of Promise:
    useEffect(function () {
      async function fetchMovies() {
        const res = await fetch(`http://www.omdbapi.com/?apikey=${KEY}&s=interstellar`);
        const data = await res.json();
        setMovies(data.Search);
      }
      fetchMovies();
    }, []);

- Loader:
    const [isLoading, setIsLoading] = useState(false);
    useEffect(function () {
      async function fetchMovies() {
        setIsLoading(true);
        const res = await fetch(`http://www.omdbapi.com/?apikey=${KEY}&s=interstellar`);
        const data = await res.json();
        setMovies(data.Search);
        setIsLoading(false);
      }
      fetchMovies();
    }, []);
    .....
    <Box>{isLoading ? <Loader /> : <MovieList movies={movies} />}</Box>

- Handling errors
  see REPO: 07-usepopcorn/usepopcorn/App.js
  ....
        <Box>
          {/* {isLoading ? <Loader /> : <MovieList movies={movies} />} */}
          {isLoading && <Loader />}
          {!isLoading && !error && <MovieList movies={movies} />}
          {error && <ErrorMessage message={error} />}
        </Box>

- Depedancy array
  + By default, effects run after every render. It can be prevented by a dependency array
  + Each time one of the dependancies changes, the effect will be executed again
  + Every state variable and prop used inside the effect MUST be included in the dependency array
      - otherwise, we get a 'stale closure'.

- effect synchronization:
  + useEffect(fn, [x, y, z]) - effect synch with x, y, z/ Runs on mount and re-renders triggered by updayting x, y, z
  + useEffect(fn, []) - effect synch with no state/props. Runs only on mount (initial render)
  + useEffect(fn) - effect synch with everything. Runs on every render (usualy bad ‚õîÔ∏è)

- Effect executed after mount-commit-browser_paint
- Layout effect - another type of effect that is very rarely necessary (useLayoutEffect). It executs after commit and before browser_paint

- Example effect synch:
    useEffect(
      function () {
        async function fetchMovies() {
          try {
            setIsLoading(true);
            setError('');
            const res = await fetch(`http://www.omdbapi.com/?apikey=${KEY}&s=${query}`);
            if (!res.ok) new Error('Something went wrong with fetching movies');

            const data = await res.json();
            if (data.Response === 'False') throw new Error('Movie not found');
            setMovies(data.Search);
          } catch (err) {
            console.error(err.message);
            setError(err.message);
          } finally {
            setIsLoading(false);
          }
        }
        if (query.length < 3) {
          setMovies([]);
          setError('');
          return;
        }
        fetchMovies();
      },
      [query],
    );

- useEffect should do only ONE action!!!

- Cleanup function can be returned from a effect(optional)
- It runs:
    + before the effect is executed again
    + after component has unmounted!!!  

- whenever the side effect keeps happening after the component has been re-rendered or unmounted

- Examples of cleanup:
    Effect-------------|  Potential Cleanup---
    HTTP request       |  Cancel requests
    API subscriptions  |  Cancel subscription
    Start timers       |  Stop timer
    Add event listener |  Remove listener

- Cleanup function to return back default page title
  useEffect(
    function () {
      if (!title) return;
      document.title = `Movie | ${title}`;
      return function () {
        document.title = 'usePopcorn';
      };
    },
    [title],
  );

- Cleanup to cancel http requests that occures after re-rendering component.

  useEffect(
    function () {
      const controller = new AbortController();

      async function fetchMovies() {
        try {
          setIsLoading(true);
          setError('');
          const res = await fetch(`http://www.omdbapi.com/?apikey=${KEY}&s=${query}`, {
            signal: controller.signal,
          });
          if (!res.ok) new Error('Something went wrong with fetching movies');

          const data = await res.json();
          if (data.Response === 'False') throw new Error('Movie not found');
          setMovies(data.Search);
          console.log(data.Search);
          setError('');
        } catch (err) {
          console.error(err.message);

          if (err.name !== 'AbortError') {
            setError(err.message);
          }
        } finally {
          setIsLoading(false);
        }
      }
      if (query.length < 3) {
        setMovies([]);
        setError('');
        return;
      }
      fetchMovies();

      return function () {
        controller.abort();
      };
    },
    [query],
  );

- One more example of clean up:
  useEffect(
    function () {
      if (!title) return;
      document.title = `Movie | ${title}`;
      return function () {
        document.title = 'usePopcorn';
        // console.log(`Clean up effect for movie ${title} (Explaination of a closure)`);
      };
    },
    [title],
  );

- use effect to close movie's details by pressong  'Esc' button:
  useEffect(
    function () {
      function callback(e) {
        if (e.code === 'Escape') {
          onCloseMovie();
          console.log('CLOSING');
        }
      }
      document.addEventListener('keydown', callback);

      return function () {
        document.removeEventListener('keydown', callback);
      };
    },
    [onCloseMovie],
  );

  - disable elements if something is loading:
      <select
        value={fromCur}
        onChange={(e) => setFromCur(e.target.value)}
        disabled={isLoading}
      >

*****************************************************************************************************************
Section 13: Custom Hooks, Refs, and More State
*****************************************************************************************************************

- React HOOKS:
    + special built-in functions that allow us hook into React internals:
        - Creating and accessing state from Fiber tree
        - Registring side effects in Fiber tree
        - Manual DOM selections, etc
    + Always start with 'use' word
    + can compose multiple hooks into our own custom hooks
    + give function component the ability to own state and run side effects at different lifecycle points

- Most popular hooks:
    + useState
    + useEffect
    + useReducer
    + useContext
    + useRef
    + useCallback
    + useMemo
    + useTransition
    + useDeferredValue, etc

- Rules of HOOKS:
    + Only call hooks at the top level
    + Only call hooks from React functions
- All tese rules are automatically enforced by React's ESLint rules

- Hook relies on call order

- Derive state. If put boolean expression into component, it will be calculated each time during re-rendering:
    const isTop = imdbRating > 8;
    console.log(isTop);

- To update value in handle function:
  function handleAdd() {
    const newWatchedMovie = {
      imdbID: selectedId,
      title,
      year,
      poster,
      imdbRating: Number(imdbRating),
      runtime: Number(runtime.split(' ').at(0)),
      userRating,
    };
    onAddWatched(newWatchedMovie);
    ///////////////// see below
    setAvgRating(Number(imdbRating));
    setAvgRating((avgRating) => (avgRating + userRating) / 2);
  }

- Save data in local storage:
      const [watched, setWatched] = useState(function () {
        const storedValue = localStorage.getItem('watched');
        return JSON.parse(storedValue);
      });

      useEffect(
        function () {
          localStorage.setItem('watched', JSON.stringify(watched));
        },
        [watched],
      );

- Creating State:
    1. Simple                               -----  const [count, setCount] = useState(23);
    2. Based on function (lazy evaluation)  -----  const [count, setCount] = useState(
                                                      () => lacolStorage.getItem('count');
                                                    )
        function - pureand without arguments
        called only on initial render
                                  
- Updating state:
    1. Simple                               -----  setCount(1000);
    2. Based on current state               -----  setCount((c) => c + 1);
        function - pure and return next state
        Make sure to NOT mutate objects or arrays, but to replace them

- Bad practice manipulate with DOM directly in React (use useRef instead this case):
    function Search({ query, setQuery }) {
      useEffect(function () {
        const el = document.querySelector('.search');
        console.log(el);
        el.focus();
      }, []);

      return (
        <input
          className="search"
          type="text"
          placeholder="Search movies..."
          value={query}
          onChange={(e) => setQuery(e.target.value)}
        />
      );
    }

- useRef - "Box" (object) with a mutable .current property that is persisted across renders ("normal" variables are always reset)
- Two big use cases:
    1. Creating a variable that stays the same between renders (previous state, setTimeout id)
    2. Selecting and storing DOM elements

- Refs are for data that is NOT rendered: usually only appear in event handlers or effects, not in JSX (otherwise use state)
- do NOT read write or read .current in render logic (like state)

- Differense | Persist across renders | Updating re-render | Immutable | Asynch updates |
    State    |          +             |         +          |     +     |        +       |
    refs     |          +             |         -          |     -     |        -       |

- useRef for focus element:
      const inputEl = useRef(null);

      useEffect(function () {
        inputEl.current.focus();
      }, []);

      return (
        <input
          className="search"
          type="text"
          placeholder="Search movies..."
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          ref={inputEl}
        />
      );
    }

- press 'Enter' key to clear search field if it's focused
    useEffect(
      function () {
        function callback(e) {
          if (document.activeElement === inputEl.current) return;

          if (e.code === 'Enter') {
            inputEl.current.focus();
            setQuery('');
            console.log('ENTER');
          }
        }
        document.addEventListener('keydown', callback);
        return () => document.addEventListener('keydown', callback);
      },
      [setQuery],
    );

- Custom hooks:
    + must start with "use" word
    + UI (component) and LOGIC (regular functions, custom hooks)
    + always non-visual logicone custom hooks should have one purpose
    + rules of hooks apply to custom hooks too
    + custom hook can have regular hooks inside

- Example of custom hook export function useLocalStorageState(initialState, key) {
    const [value, setValue] = useState(function () {
      const storedValue = localStorage.getItem(key);
      return storedValue ? JSON.parse(storedValue) : initialState;
    });

    useEffect(
      function () {
        localStorage.setItem(key, JSON.stringify(value));
      },
      [value, key],
    );

    return [value, setValue];
  }

  - CHALLENGE: useGeolocate. (case when hook returns also function):
      https://codesandbox.io/p/sandbox/react-challenge-usegeolocation-tkqszl?file=%2Fsrc%2FApp.js%3A60%2C1

            function useGeolocation() {
              const [isLoading, setIsLoading] = useState(false);
              const [position, setPosition] = useState({});
              const [error, setError] = useState(null);

              function getPosition() {
                if (!navigator.geolocation)
                  return setError("Your browser does not support geolocation");

                setIsLoading(true);
                navigator.geolocation.getCurrentPosition(
                  (pos) => {
                    setPosition({
                      lat: pos.coords.latitude,
                      lng: pos.coords.longitude,
                    });
                    setIsLoading(false);
                  },
                  (error) => {
                    setError(error.message);
                    setIsLoading(false);
                  }
                );
              }
              return { isLoading, position, error, getPosition };
            }

            export default function App() {
              const [countClicks, setCountClicks] = useState(0);

              function handleClick() {
                setCountClicks((count) => count + 1);
                getPosition();
              }

              const {
                isLoading,
                position: { lat, lng },
                error,
                getPosition,
              } = useGeolocation();

              return (
                <div>
                  <button onClick={handleClick} disabled={isLoading}>
                    Get my position
                  </button>

                  {isLoading && <p>Loading position...</p>}
                  {error && <p>{error}</p>}
                  {!isLoading && !error && lat && lng && (
                    <p>
                      Your GPS position:{" "}
                      <a
                        target="_blank"
                        rel="noreferrer"
                        href={`https://www.openstreetmap.org/#map=16/${lat}/${lng}`}
                      >
                        {lat}, {lng}
                      </a>
                    </p>
                  )}

                  <p>You requested position {countClicks} times</p>
                </div>
              );
            }

*****************************************************************************************************************
Section 14: [Optional] React Before Hooks: Class-Based React
*****************************************************************************************************************

- Optional. Outdated approach

*****************************************************************************************************************
Section 16: The Advanced useReducer Hook
*****************************************************************************************************************

- useReducer hook
    const initialState = { count: 0, step: 1 };
    function reducer(state, action) {
      console.log(state, action);

      switch (action.type) {
        case 'dec':
          return { ...state, count: state.count - 1 };
        case 'inc':
          return { ...state, count: state.count + 1 };
        case 'setCount':
          return { ...state, count: action.payload };
        case 'setStep':
          return { ...state, step: action.payload };
        case 'reset':
          return initialState;
        default:
          throw new Error('Unknown action');
      }
    }

    function DateCounter() {
      const [state, dispatch] = useReducer(reducer, initialState);
      const { count, step } = state;

      // This mutates the date object.
      const date = new Date('june 21 2027');
      date.setDate(date.getDate() + count);

      const dec = function () {
        dispatch({ type: 'dec' });
      };

        const defineCount = function (e) {
        dispatch({ type: 'setCount', payload: Number(e.target.value) });
      };

        const reset = function () {
        dispatch({ type: 'reset' });
      };
      ......

- Why reducer:
    1. a lot of state vars and state updates spread across many handlers
    2. multiple updates need to happen at the same time
    3. Updating a piece of state  depends on one or multiple other pieces of state

- useRedicer:
    + alternative way to set state, ideal for complex state and related pieces of state
    + stores related pieces of state in a state object (see above)
    + useReducer needs reducer: func contains all logic to update state
    + reducer: pure func (no side effects) that takes current state and action, and returns the next state
    + action: object that describes how to update state
    + dispatch: func to trigger state updates by sending action from event handlers to the reducer (agreed to use scheme: { type: '...', payload: ... })

- Install fake server:
    npm i json-server

      "scripts": {
        "server": "json-server --watch ./data/cities.json --port 8000"
        ......

- Use reduce function to calculate sum:
  const maxPossiblePoints = questions.reduce((prev, cur) => prev + cur.points, 0);

- Clean up function to stop timer between renders
    function Timer({ dispatch, secondsRemaining }) {
      useEffect(
        function () {
          const id = setInterval(function () {
            dispatch({ type: 'tick' });
          }, 1000);

          return () => clearInterval(id);
        },
        [dispatch],
      );
      return <div className="timer">{secondsRemaining}</div>;
    }

- CHALLENGE #1: Creating a Bank Account With useReducer: https://codesandbox.io/p/sandbox/react-challenge-usereducer-bank-starter-forked-3xmr2v?file=%2Fsrc%2FApp.js

*****************************************************************************************************************
Section 17: React Router: Building Single-Page Applications (SPA)
*****************************************************************************************************************

- Set up Vite project
    + Install project via Vite:
        npm create vite@latest
    + Run Vite project
        npm run dev
    + Install Eslint:
        npm install eslint vite-plugin-eslint eslint-config-react-app --save-dev
    + Create file: /worldwise/.eslintrc.json
        {
          "extends": "react-app"
        }
    + Add eslint plugin to /worldwise/src/main.jsx
        import eslint from 'vite-plugin-eslint';
        export default defineConfig({
          plugins: [react(), eslint()],
        });

- Routing - match different URLs to different UI views (React components): routes
- This enables users to navigate between different Applications screens, using the browser URL
- Keeps the UI in sync with the current browser URL
- React Router is use as third-party libraries
- It allows us to create Single Page Application (SPA)

- Single-Page Application (SPA) is executed entirely on the client (browser)
- Routes: different URLs correspond to different views(components)
- JavaScript (React) is used to update the page (DOM)
- The page is never reloaded
- Feels like a native app
- Additional data might be loaded from web API
      user clicks router link ---> URL is changed ---> DOM is updated: React component corresponding to the new URL is rendered

- install react router package:
     npm i react-router-dom@6

- Define route example:
    const App = () => {
      return (
        <BrowserRouter>
          <Routes>
            <Route path="/" element={<Homepage />} />
            <Route path="product" element={<Product />} />
            <Route path="pricing" element={<Pricing />} />
            <Route path="*" element={<PageNotFound />} />
          </Routes>
        </BrowserRouter>
      );
    };

- use nav panel in component:
    const PageNav = () => {
      return (
        <nav>
          <ul>
            <li>
              <Link to="/">Home</Link>
            </li>
            <li>
              <Link to="/pricing">Pricing</Link>
            </li>
            <li>
              <Link to="/product">Product</Link>
            </li>
          </ul>
        </nav>
      );
    };
- Usage:
    const Product = () => {
      return (
        <div>
          <PageNav />
          <h1>Product</h1>
        </div>
      );
    };

- To mark selected item use "NavLink" instead of "Link". It adds class="active" to selected element and we can change it via CSS:
  const PageNav = () => {
    return (
      <nav>
        <ul>
          <li>
            <NavLink to="/">Home</NavLink>
          </li>
          <li>
            <NavLink to="/pricing">Pricing</NavLink>
          </li>
          <li>
            <NavLink to="/product">Product</NavLink>
          </li>
        </ul>
      </nav>
    );
  };

- Styling options in React:
    + Inline CSS (style props in JSX elements)
    + CSS or Sass file (external file - Entire app - globally)
    + CSS Modules (One external file per component)
    + Css in JS (External file or component file)
    + Utility-first CSS (JSX elements) - tailwindcss
    + Alternative to styling with CSS: UI libs like MUI, Chakra UI, Mantine etc.

- In module CSS you should use class not tag names(it will not work)
- Usage module CSS:
    + worldwise/src/components/PageNav.jsx
          import styles from './PageNav.module.css';
          const PageNav = () => {
            return (
              <nav className={styles.nav}>
              .....
    + worldwise/src/components/PageNav.module.css
          .nav {
            background-color: orangered;
          }

          .nav ul {
            list-style: none;
            display: flex;
            justify-content: space-between;
          }

- React create random class: class="_nav_2srth_1"
- To give some particular class styler need to use global:
      .nav :global(.active) {
        background-color: green;
      }

- Usage style class in different component can be with global function:
    + worldwise/src/components/PageNav.jsx
        :global(.test) {
          background-color: red;
        }
    + worldwise/src/pages/Homepage.jsx
        const Homepage = () => {
          return (
            <div>
              <PageNav />
              <AppNav />
              <h1 className='test'>WorldWise</h1>
              ...

- Snipet
    "importCSSModule": {
      "prefix": "csm",
      "scope": "javascript,typescript,javascriptreact",
      "body": ["import styles from './${TM_FILENAME_BASE}.module.css'"],
      "description": "Import CSS Module as `styles`"
    },

- Use nested Routing: like /app/cities (Outlet like childrent elements)
    const App = () => {
      return (
        <BrowserRouter>
          <Routes>
            <Route path="/" element={<Homepage />} />
              ....
            <Route path="app" element={<AppLayout />}>
              <Route index element={<p>LIST</p>} />             ---------  DEFAULTE
              <Route path="cities" element={<p>List of cities</p>} />
              <Route path="countries" element={<p>Countries</p>} />
              <Route path="form" element={<p>Form</p>} />
            </Route>
            ....

    const AppLayout = () => {
      return (
        <div className={styles.app}>
          <Sidebar />
          <Map />
          ....
    
    const Sidebar = () => {
      return (
        <div className={styles.sidebar}>
          <Logo />
          <AppNav />

          <Outlet />
          ....

- To link previous nested rout with web elements:
    const AppNav = () => {
      return (
        <nav className={nav}>
          <ul>
            <li>
              <NavLink to="cities">Cities</NavLink>
            </li>
            <li>
              <NavLink to="countries">Countries</NavLink>
            </li>
            ....

- the URL for state management:
  + The URL is an excelent place to store UI state and an alternative to useState in some situations!
    Examples: open/closed panels, currently selected list item, list sorting order, applied list filters

  1. Easy way to store in a "global place", accessible to all components in the app
  2. Good way to "pass" data from one page into the next page
  3. Makes it possible to "bookmark and share" the page with the exact UI state it had at the time

  www.example.com/app/cities/lisbon?lat=38.4343&lng=-9.743864
  /app/cities - path
  lisbon - parameters
  lat=38.4343&lng=-9.743864 - query string

  City name and GPS location were retrieved from the URL instead of application state!

- Create a route to open certain component when the link is matche the pattern
         <Route path="cities/:id" element={<City />} />
- Add link too component with the same pattern which will lead to previous component after click
          const CityItem = ({ city }) => {
            const { cityName, emoji, date, id } = city;
            return (
              <li>
                <Link className={styles.cityItem} to={`${id}`}>
                .....

- Then we can read param from URL using useParams hook
    function City() {
      const { id } = useParams();
      ...

- Set search params to URL
     <Link className={styles.cityItem} to={`${id}?lat=${position.lat}&lng=${position.lng}`}>

- Get Search params from URL
    const [searchParams, setSerchParams] = useSearchParams();
    const lat = searchParams.get('lat');
    const lng = searchParams.get('lng');

- Update search params in URL
      <button
        onClick={() => {
          setSerchParams({ lat: 23, lng: 50 });
        }}
      >
        Change pos
      </button>

- Imperitive way - useNavigate - navigate to another page without clicking any butto, for instance after submitting form:
    const Map = () => {
      const navigate = useNavigate();
      const [searchParams, setSerchParams] = useSearchParams();
      const lat = searchParams.get('lat');
      const lng = searchParams.get('lng');
      return (
        <div
          className={styles.mapContainer}
          onClick={() => {
            navigate('form');
          }}>
          ...

- navigate to previous page (-1)
        <Button
          type="back"
          onClick={(e) => {
            // prevent re-submit all form(re-rendering) because button inside the form
            e.preventDefault();
            // move to previous page
            navigate(-1);
          }}
        >
          &larr; Back
        </Button>

- Declaritive way. Usually is not used. It's used a s for home page to navigate to particular URL
        <Route path="app" element={<AppLayout />}>
          <Route index element={<Navigate replace to="cities" />} />
          <Route path="cities" element={<CityList cities={cities} isLoading={isLoading} />} />
          ....

*****************************************************************************************************************
Section 18: Advanced State Management: The Context API
*****************************************************************************************************************

- PROJECT: 12-atomic-blog/atomic-blog

- A prop drilling. Sollutions:
    1. Passing props through all level into deeply nested components (BAD SOLUTION)
    2. Context API. Read state everywhere (GOOD SOLUTION)

- Context API:
    + System to pass data throughout the app withiut manually passing props down the tree
    + Allows us to "broadcast" global state to the entire app

    1. Provider: gives all child components access to value
    2. value: data that we want to make available (usually state and functions)
    3. Consumers: all components that read the provided context value

    value is updated -> all consumers re-render

- Flow:
    1. Create a new context
       const PostContext = createContext();
    2. Provide value to the child component
        <PostContext.Provider
          value={{
            posts: searchedPosts,
            onAddPost: handleAddPost,
            onClearPosts: handleClearPosts,
            searchQuery,
            setSearchQuery,
          }}
        >
          <section>
            <button
              onClick={() => setIsFakeDark((isFakeDark) => !isFakeDark)}
              className="btn-fake-dark-mode"
            >
              {isFakeDark ? '‚òÄÔ∏è' : 'üåô'}
            </button>

            <Header
              posts={searchedPosts}
              onClearPosts={handleClearPosts}
              searchQuery={searchQuery}
              setSearchQuery={setSearchQuery}
            />
            <Main posts={searchedPosts} onAddPost={handleAddPost} />
            <Archive onAddPost={handleAddPost} />
            <Footer />
          </section>
        </PostContext.Provider>
    3. Consuming context value
      function Header() {
        const { onClearPosts } = useContext(PostContext);
        return (
          <header>
            <h1>
              <span>‚öõÔ∏è</span>The Atomic Blog
            </h1>
            <div>
              <Results />
              <SearchPosts />
              <button onClick={onClearPosts}>Clear posts</button>
            </div>
          </header>
        );
      }

- 1. Better to use API Context as a Component:
    function PostProvider({ children }) {
      ....
        return (
        // 2. Provide value to the child component
        <PostContext.Provider
          value={{
            posts: searchedPosts,
            onAddPost: handleAddPost,
            onClearPosts: handleClearPosts,
            searchQuery,
            setSearchQuery,
          }}
        >
          {children}
        </PostContext.Provider>
      );
    function usePosts() {
      const context = useContext(PostContext);
      if (context === undefined) throw new Error('PostContext was used outside of the PostProvider');
      return context;
    }
    export { PostProvider, usePosts };

- 2. Usage
      <PostProvider>
        <Header />
        <Main />
        <Archive />
        <Footer />
      </PostProvider>
      -------
    // 3. Consuming context value
    const { onClearPosts } = usePosts();

- Types of State:
    1. State Accessibility: 
        + Local State   - Need only by one or few components
                        - Only accessible in component and child
                        - If your component was rendered twice, should a state update in one of them reflected one? - NO

        + Global State  - Might be needed by many components
                        - Accessible to every component in the application
                        - If your component was rendered twice, should a state update in one of them reflected one? - YES

    2. State Domain:
        + Remote State  - All application data loaded from a remote server (API)
                        - Usually asynchronously
                        - Needs re-fetching + updating
        + UI State      - Everything else :)
                        - Theme, list filters, from data, etc.
                        - Usually synchronous and stored in the application

- State placement option:
    + Local component   - Tools: useState, useReducer or useRef
                        - When: Local state
    + Parent component  - Tools: useState, useReducer or useRef
                        - When: Lifting up state
    + Context           - Tools: Context API + useState or useReducer
                        - When: Global state (Preferably UI state)
    + 3rd-party library - Tools: Redux, React Query, SWR, Zustand, etc.
                        - When: Global state (remote or UI)
    + URL               - Tools: React Router
                        - When: Global State, passing between pages
    + Browser           - Tools: Local storage, session storage, etc
                        - When: Storing data in user's browser

- To ommit redirecting to login page after Log In clicking 'Back' button in btowser use:
    useEffect(
      function () {
        if (isAuthenticated) navigate('/app', { replace: true });
      },
      [isAuthenticated, navigate],
    );

- Redirect to root if not authenticated. Created own componet and call it in App.jsx
        const ProtectedRoute = ({ children }) => {
          const { isAuthenticated } = useAuth();
          const navigate = useNavigate();
          useEffect(
            function () {
              if (!isAuthenticated) navigate('/');
            },
            [isAuthenticated, navigate],
          );

          return isAuthenticated ? children : null;
        };
        ........
                    <Route path="login" element={<Login />} />
            <Route
              path="app"
              element={
                <ProtectedRoute>
                  <AppLayout />
                </ProtectedRoute>
              }
            >
              <Route index element={<Navigate replace to="cities" />} />
              .....

*****************************************************************************************************************
Section 19: Performance Optimization and Advanced useEffect
*****************************************************************************************************************

- performance Optimization Tools
  1. prevent wasted renders
    + memory
    + useMemo
    + useCallback
    + passing elements as children or regular prop
  2. improve app speed/responsiveness
    + memory
    + useMemo
    + useCallback
  3. reduce bundle size
    + using fewer 3rd-party packages
    + code splitting and lazy loading

- When does a component instance re-render:
    + state changes
    + context changes
    + parent re-renders (creates the false impression that changing props re-renders a component. This is NOT true)

- Remember: a render does not mean that the DOM actuallyu gets updated, it just means the component functiongets called. But this can be expensive operation.
- Wasted render: a render that didn't produce any changes in DOM
- Only a problem when they happen too frequently or when the component is very slow

- For debug. Use Dev Tools plugin React(Components and Profiler) -> Profiler
- Set up it: Settings -> "Record why each component rendered while profiling"=True
- Record and change state

- Trick optimization with children props (React just creates slow component before passing into component as child):
  + Slow
    function SlowComponent() {
      // If this is too slow on your maching, reduce the `length`
      const words = Array.from({ length: 100_000 }, () => 'WORD');
      return (
        <ul>
          {words.map((word, i) => (
            <li key={i}>
              {i}: {word}
            </li>
          ))}
        </ul>
      );
    }
    export default function Test() {
      const [count, setCount] = useState(0);
      return (
        <div>
          <h1>Slow counter?!?</h1>
          <button onClick={() => setCount((c) => c + 1)}>Increase: {count}</button>
          <SlowComponent />
        </div>
      );
    }

  + Fast:
    function Counter({ children }) {
      const [count, setCount] = useState(0);
      return (
        <div>
          <h1>Slow counter?!?</h1>
          <button onClick={() => setCount((c) => c + 1)}>Increase: {count}</button>
          {children}
        </div>
      );
    }

    export default function Test() {
      return (
        <div>
          <h1>Slow counter?!?</h1>
          <Counter>
            <SlowComponent />
          </Counter>
        </div>
      );
    }

- Memoization - optimization technique that executes a pure function once, and saves the result in memory. 
  If we try to execute the function again with the same arguments as before, previous saved will be returned, 
  without executing the function again.
    + Momoize components with memory
    + Memoize objects with use 
    + MemoMemoize functions with useCallback
  1. Prevent wasted renders
  2. Improve app speed/resposivnes

- Memoized component - not render if its parent re-render as long as props stay the same beween renders
- Only affects props! A memorized component will still re-render when its own state changes or when a context that it's subscribed to changes
- Only makes sence when the component is heavy (slow rendering), re-renders often, and does so with the same props

- Add component to memo, just wrap by memo function:
    const Archive = memo(function Archive({ show }) {
      ......

- useMemo - memorize values between renders
- useCallback - memorize function between renders
- values passed into useMemo and use Callback will be stored in memory ('cached') and returned in subsequent re-renders, as long as dependencies ('inputs') stay the same
- useMemo and useCallback have a dependency array (like useEffect): whenever one dependency changes, the value will be re-created

Three big uses cases:
1. Memoizing props to prevent wasted renders (together with memo)
2. Memoizing values to avoid expensive re-calculations on every render
3. Memoizing values that are used in dependancy array of another hook

- Example useMemo: 
  const archiveOptions = useMemo(() => {
    return {
      show: false,
      title: 'Post archive in addition to main posts',
    };
  }, []);

  const archiveOptions = useMemo(() => {
    return {
      show: false,
      title: `Post archive in addition to ${posts.length} main posts`,
    };
  }, [posts.length]);

  - Example useCallback:
  const handleAddPost = useCallback(function handleAddPost(post) {
    setPosts((posts) => [post, ...posts]);
  }, []);

- Optimize context (only if all 3 are true):
    1. State in the context needs to change all the time
    2. Context has many consumers
    3. App is slow and laggy
    
- Bundle and code splitting
    + Bundle - JS file containing the entire application code. Downloading the bundle will load the entire app at once, turning it into a SPA
        - Vite
        - Webpack (inside create-react-app)
    + Bundle Size - amount of JS users have to download to start using app. One of the most important things to be optimized, so that the bundle takes less time to download.
    + Code splitting - splitting bundle into multiple parts that can be downloaded over time ("lazy loading")

- Example of lazy load in App.js:
  // import Homepage from './pages/Homepage';
  const Homepage = lazy(() => import('./pages/Homepage'));

- Add Suspense API for lazy load with falback attribute (to display spinner meanwhile):
  const App = () => {
  return (
    <AuthProvider>
      <CitiesProvider>
        <BrowserRouter>
          <Suspense fallback={<SpinnerFullPage />}>  
            <Routes>
              <Route index element={<Homepage />} />
              <Route path="product" element={<Product />} />

- Don't optimize prematuraly:
    + find performance bottleneck using Profile and visual inspection (laggy UI)
    + Fix those real performance issues
    + Memoize expensive re-renders
    + Memoize expensive calculations
    + Optimize context if it has many consumers and changes often
    + Memoize context value + child components
    + Implement code splitting + lazy loading for SPA routes

- useEffect dependency array rules:
    + Every state variable, prop and context value used inside the effect MUST be included in the dependency array
    + All "reactive values" must be included! That means any function or variable that reference any other reactive values
    + Dependencies choose themselves: NEVER ignore the exhaustive-deps ESLint rule!
    + Do NOT use objects or arrays as dependencies (objects are reacted on each render and React sees new objects as different, {} !== {})

- Removing unnecessary dependencies:
    + Removing function dependencies:
        - Move function into the effect
        - if you need the function in multiple place, memoize it (useCallback)
        - if the function doesn't reference any reactive values, move it out of the component
    + Removing object dependencies:
        - Instead of including the entire object, include only the properties you need (primitive values)
        - if that doesn't work, use the same strategies as for functions (moving or memoizing object)
    + Other strategies
        - if you have multiple related reactive values as dependencies, try using a reducer (useReducer)
        - you don't need to include setState (from useState) and dispatch (from useReducer) in the dependencies, as React guarantees them to be stable across renders

- When NOT to use an effect
    + Effects should be used as a last resort, when no other solution makes sense. React calls them an 'escape hatch' to step outside of React

- Three cases where effects are overused:
    1. Responding to a user event. An event handler function should be used instead
    2. Fetching data on component mount. This is fine in small apps, but in real-world app, a library like React Query should be used
    3. Synchronizing state changes with one another (setting state based on another state variable). Try to use derived state and event handlers

- Stale closure - when fuction was created initialy and point to init 'snapshot' of 'number' var (outdated value)
  useEffect(function() {
    document.title = `Your ${number}-exercise workout`
  }, [])

- Re-execute function, just use dependany array 
  useEffect(function() {
    document.title = `Your ${number}-exercise workout`
  }, [number])

*****************************************************************************************************************
Section 20: Redux and Modern Redux Toolkit (With Thunks)
*****************************************************************************************************************

- Redux:
    + 3rd-party lib to manage global state
    + Standalone lib, but easy to integrate with React apps using react-redux lib
    + All global state is stored in one globaly accessible store, which is easy to update using "actions" (like useReducer)
    + It's conceptually similar to using the Contex API + useReducer
    + Two "versions": (1) Classic Redux, (2) Modern Redux Toolkit

- Global store is updated -> All consuming components re-render

- Historically Redux was used in most Reacts apps for all global stae. Today that has changed, necause there are many alternatives. Many apps don't need a lot of global UI state.
    + UI Local State: useState, useReducer, useRef
    + UI Global State: Context API + useState/useReducer; Redux, Zustand, Recoil, etc; React Router
    + Remote Local State: fetch + useEffect + useState/useReducer
    + Remote Global State: Context API + useState/useReducer; Redux, Zustand, Recoil, etc; React Query; SWR; RTK Query

- Mechanism of the useReducer hook:
    + Event handler in component(action with type and payload) -> dispatch -> reducer(current state) -> Next state -> Re-render\

- Mechanism of the Redux hook:
    + Event handler in component -> Action creator function(auto create action with type and payload) -> dispatch -> STORE with multiple reducers(current state) -> Next state -> Re-render
    
- Setup redux project:
    + npx create-react-app@5 redux-intro
    + npm i redux
- Example as a beggining: 
      import { createStore } from 'redux';
      const initialState = {
        balance: 0,
        loan: 0,
        loanPurpose: '',
      };
      function reducer(state = initialState, action) {
        switch (action.type) {
          case 'account/deposit':
            return { ...state, balance: state.balance + action.payload };
          case 'account/withdraw':
            return { ...state, balance: state.balance - action.payload };
          case 'account/requestLoan':
            if (state.loan > 0) return state;
            // later
            return {
              ...state,
              loan: action.payload.amount,
              loanPurpose: action.payload.purpose,
              balance: state.balance + action.payload.amount,
            };
          case 'account/payloan':
            return { ...state, loan: 0, loanPurpose: '', balance: state.balance - state.loan };
          default:
            return state;
        }
      }
      const store = createStore(reducer);
      store.dispatch({ type: 'account/deposit', payload: 500 });

- combine 2 reducers:
    const rootReducer = combineReducers({ account: accountReducer, customer: customerReducer });
    const store = createStore(rootReducer);

- Provider for stor to components:
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(
        <React.StrictMode>
          <Provider store={store}>
            <App />
          </Provider>
        </React.StrictMode>,
      );

- Get state from store in components:
    import { useSelector } from 'react-redux';
    function Customer() {
      const customer = useSelector((store) => store.customer.fullName);
      console.log(customer);

- Dispatching Actions from Our React App:
  const dispatch = useDispatch();
  function handleClick() {
    if (!fullName || !nationalId) return;
    dispatch(createCustomer(fullName, nationalId));
  }

- The Legacy Way of Connecting Components to Redux. Old way to use 'balance' value from state in component:
    function mapStateToProps(state) {
      return {
        balance: state.account.balance,
      };
    }
    export default connect(mapStateToProps)(BalanceDisplay);

- Redux Middleware and Thunks. 
  What is Redux Middleware?
  'COMPONENT' --> 'dispatch' --> 'MIDDLEWARE' --> 'STORE'
  Middleware - functions that sits between dispatching the actions and store:
    + perfect for async code
    + API calls, timers, logging
    + The place for side effects
  Redux Thunks - 3rd-party lib for middleware

- Making an API Call With Redux Thunks
  npm i redux-thunk
  const store = createStore(rootReducer, applyMiddleware(thunk));
  If we return in action function, redux will know that it's async (middleware) 
    export function deposit(amount, currency) {
      if (currency === 'USD') return { type: 'account/deposit', payload: amount };
      return async function (dispatch, getState) {
        dispatch({ type: 'account/convertingCurrency' });
        const res = await fetch(
          `https://api.frankfurter.app/latest?amount=${amount}&from=${currency}&to=USD`,
        );
        const data = await res.json();
        const converted = data.rates.USD;
        console.log(converted);
        dispatch({ type: 'account/deposit', payload: converted });
      };
    }

- The Redux DevTools:
  Install Redux DevTools Chrome extention
  npm i redux-devtools-extension
  import { composeWithDevTools } from 'redux-devtools-extension';
  const store = createStore(rootReducer, composeWithDevTools(applyMiddleware(thunk)));

- What is Redux Toolkit (RTK)? 
    + the modern way to write Redux code
    + the opinionated approach, forcing us to use Redux best practice
    + 100% compatiable to old Redux, allowing usage together in one app
    + allows us to write a lot less code to achive the same (less "boilerplate")
    + give us 3 big things (but there are many more...):
      1. we can write code that mutates state inside reducer (will be converted to immutable logic behind the scenes by "Immer" library)
      2. action creators are automaticaly created
      3. Automatic setup of thunk middleware and DevTools

- Creating the Store With RTK.
  npm i @reduxjs/toolkit
  Simplify store.js
  import { configureStore } from '@reduxjs/toolkit';
  import accountReducer from './features/accounts/accountSlice';
  import customerReducer from './features/customers/customerSlice';
  const store = configureStore({ reducer: { account: accountReducer, customer: customerReducer } });
  export default store;

- Creating the Account Slice
  Reducer can accept only one parameter as payload, so need to prepare data before pass it into reducer
      import { createSlice } from '@reduxjs/toolkit';
      const initialState = {
        balance: 0,
        loan: 0,
        loanPurpose: '',
        isLoading: false,
      };
      const accountSlice = createSlice({
        name: 'account',
        initialState,
        reducers: {
          deposit(state, action) {
            state.balance += action.payload;
          },
          withdraw(state, action) {
            state.balance -= action.payload;
          },
          requestLoan: {
            prepare(amount, purpose) {
              return {
                payload: { amount, purpose },
              };
            },
            reducer(state, action) {
              if (state.loan > 0) return;
              state.loan = action.payload.amount;
              state.loanPurpose = action.payload.purpose;
              state.balance += action.payload.amount;
            },
          },
          payLoan(state, action) {
            state.balance -= state.loan;
            state.loan = 0;
            state.loanPurpose = '';
          },
        },
      });
      export const { deposit, withdraw, requestLoan, payLoan } = accountSlice.actions;
      export default accountSlice.reducer;

- Back to Thunks - re-use the old approach, because it's more simple for now than approach from redux toolkit

- Redux vs. Context API (+useReducer)

*****************************************************************************************************************
Section 21: PART 4: PROFESSIONAL REACT DEVELOPMENT [2 PROJECTS]
*****************************************************************************************************************

*****************************************************************************************************************
Section 22: React Router With Data Loading (v6.4+)
*****************************************************************************************************************

- Setting Up a New Project: "Fast React Pizza Co."
    npm create vite@4 //// or vite@latest
    cd fast-react-pizza
    npm i
    npm i eslint vite-plugin-eslint eslint-config-react-app --save-dev
    Create file ".eslintrc.json":
    {
        "extends": "react-app"
    }
    Add in "vite.config.js" file:
    import eslint from "vite-plugin-eslint"
    export default defineConfig({
      plugins: [react(), eslint()],
    })
    Clean project fron unnecessary files and run it:
    npm run dev

- Application Planning:
    1. Gather app requirements and features
    2. Divide the app into pages
        - Think about the overall and page-level UI
        - Break desire UI into components
        - Design and build a static version
    3. Divide the app into feature categories
        - Think about state management + data flow
    4. Decide on what lib to use (technology decision)

- Step 1. Project requirements:
    + user can order one or more pizzas from menu
    + requires no user accounts and no login
    + pizza menu can change. It should loaded from the API
    + user can add multiple pozzas to cart before ordering
    + ordering requires name, phone number and address
    + if possible GPS location should also be provided to make delivery easier
    + users can mark their order as priority for additiional 20% of the cart price
    + orders are made by sending POST request wit the order data to the API
    + all payments are made on delivery, no payment processing
    + each order gets unique ID that should be displayed to get their order by ID
    + user should have ability ro mark the order as priority even after it has been placed

- Step 2 + 3. Feature + Pages.
    + Feature categories:
        - User
        - Menu
        - Cart
        - Order
    + Necessary pages:
        - Homepage (/)
        - Pizza Menu (/menu)
        - Cart (/cart)
        - Placing a new order (/order/new)
        - Looking up an order (/order/:orderID)
    
- Step 4 + 5. State management and technology decision
    + State domain / slices - type of state
        - User - Global UI state (no accounts so stay in app)
        - Menu - Global remote state (fetched from API)
        - Cart - Global UI state (no need API so stay in app)
        - Order - Global remote state (fetched and submitted to API)
    + Technology decision
        - Routing - ReactRouter (standart for React SPAs)
        - Styling - tailwindcss (trendy way)
        - Remote state management - ReactRouter (New way of fetching data)
        - UI state management - Redux (State is fairly complex)

- A New Way Of Implementing Routes:
    - npm i react-router-dom@6

- Building AppLayout:
      const router = createBrowserRouter([
        {
          element: <AppLayout />,     --------- LayOut rout
          children: [
            {
              path: '/',
              element: <Home />,
            },
            {
              path: '/menu',
              element: <Menu />,
            },
            {
              path: '/cart',
              element: <Cart />,
            },
            {
              path: '/order/new',
              element: <CreateOrder />,
            },
            {
              path: '/order/:orderId',
              element: <Order />,
            },
          ],
        },
      ]);
      ----------
      const AppLayout = () => {    ------ parent component for every single rout in application
        return (
          <div>
            <Header />
            <main>
              <h1>Content</h1>
              <Outlet />          ------- to show/render content nested components from router
            </main>
            <CartOverview />
          </div>
        );
      };

- Fetching Data With React Router "Loaders": Pizza Menu:
        function Menu() {
          const menu = useLoaderData();    ----------- using hook to fetch data
          console.log(menu);
          return (
            <ul>
              {menu.map((pizza) => (
                <MenuItem pizza={pizza} key={pizza.id} />
              ))}
            </ul>
          );
        }
        export async function loader() {      ------ fetching data from API
          const menu = await getMenu();
          return menu;
        }
        --------------
        import Menu, { loader as menuLoader } from './features/menu/Menu';
        .....
              {
                path: '/menu',
                element: <Menu />,
                loader: menuLoader,            -----  rendering during fetching data
              },

- Displaying a Loading Indicator:
  Just create Loader component and put it in Layout component using useNavigation hook. Loader will appear in every page 
    const AppLayout = () => {
      const navigation = useNavigation();
      const isLoading = navigation.state === 'loading';
      console.log(navigation);

      return (
        <div className="layout">
          {isLoading && <Loader />}
          <Header />
          <main>
            <h1>Content</h1>
            <Outlet />
          </main>
          <CartOverview />
        </div>
      );
    };

- Handling Errors With Error Elements
      const router = createBrowserRouter([
        {
          element: <AppLayout />,
          errorElement: <Error />, --- Error component
          children: [
            {
              path: '/',
              element: <Home />,
            },
            {
              path: '/menu',
              element: <Menu />,
              errorElement: <Error />, ---- to place it in page inside, but not replace all content in there
              loader: menuLoader,
            },
            {
              path: '/cart',
              element: <Cart />,
            },
            {
              path: '/order/new',
              element: <CreateOrder />,
            },
            {
              path: '/order/:orderId',
              element: <Order />,
            },
          ],
        },
      ]);
      -----
      function Error() {
        const navigate = useNavigate();
        const error = useRouteError(); --- hook to fetch error message 

        return (
          <div>
            <h1>Something went wrong üò¢</h1>
            <p>{error.data || error.message}</p>
            <button onClick={() => navigate(-1)}>&larr; Go back</button>
          </div>
        );
      }

- Fetching Orders

- Writing Data With React Router "Actions"
      const router = createBrowserRouter([
        {
          element: <AppLayout />,
      ......
            {
              path: '/order/new',
              element: <CreateOrder />,
              action: createOrderAction,
            },
            .....
      ----------------
      function CreateOrder() {
      ......
        return (
      ......
            {/* <Form method="POST" action='/order/new'>  --- action can be omitted in this case*/}
            <Form method="POST">
              <div>
              .........
      .......
      export async function action({ request }) {
        const formData = await request.formData();
        const data = Object.fromEntries(formData);
        const order = {
          ...data,
          cart: JSON.parse(data.cart),
          priority: data.priority === 'on',
        };
        const newOrder = await createOrder(order);
        return redirect(`/order/${newOrder.id}`);
      }

- Error Handling in Form Actions
        export async function action({ request }) {
        .....
          const order = {
            ...data,
            cart: JSON.parse(data.cart),
            priority: data.priority === 'on',
          };

          const errors = {};
          if (!isValidPhone(order.phone)) {
            errors.phone = 'Please give us your correct phone number.';
          }
          if (Object.keys(errors).length > 0) return errors;

          const newOrder = await createOrder(order);
          return redirect(`/order/${newOrder.id}`);
        }
        --------------
        function CreateOrder() {
        .......
          const formErrors = useActionData();
          ......
                <div>
                  <label>Phone number</label>
                  <div>
                    <input type="tel" name="phone" required />
                  </div>
                  {formErrors?.phone && <p>{formErrors.phone}</p>}
                </div>
                .....

*****************************************************************************************************************
Section 23: [Optional] Tailwind CSS Crash Course: Styling the App
*****************************************************************************************************************

- What is Tailwind CSS - utility-first CSS framework with utility classes like 'flex', 'text-center' and 'rotate-90'
- can be composed to build any design, directly in your markup (HTML, JSX)
- Utility-first approach - writing tiny classes with one single purpose, then combining them to build entire layouts
- theses classes are already written for us

Cons:
  - don't think about class names
  - no jumping between files to write markup and styles
  - immediatly understand styling
  - there are many design decisions
  - save a lot of time
  - Docs and VS Code integration

Pros:
  - Markup is unreadable
  - have to learn all native classes
  - install and set-up Tailwind CSS
  - You are givving up 'vanila CSS'

- Setting Up Tailwind CSS. 
  - Install for vite project. Follow the docs: https://tailwindcss.com/docs/guides/vite
  - Install VS Code "Tailwind CSS IntelliSense" extention
  - Install tailwind prettier extension. Follow the docs: https://github.com/tailwindlabs/prettier-plugin-tailwindcss

- Example: 
  <h1 className="text-xl text-yellow-500 font-semibold">

- Working With Color:
  <div class="bg-stone-800 text-stone-200">

- Styling Text
  <Link to="/" className="tracking-widest">
  <Link to="/" className="tracking-[5px]">
  <h1 className="text-xl">
  <h1 className="text-[2rem]">

- The Box Model: Spacing, Borders, and Display
  mb-4  - margin-bottom
  lassName="my-10" - marging top and bottom
  <header className="px-4 py-3"> padding left and right, padding top and bottom
  border-b border-stone-500 - border-bottom and border-color
  py-4	- padding-top: 1rem; /* 16px */ and padding-bottom: 1rem; /* 16px */
  space-x-4 - 	margin-left: 1rem; /* 16px */
  hidden -	display: none;

- Responsive Design.
    sm	640px	@media (min-width: 640px) { ... }
    md	768px	@media (min-width: 768px) { ... }
    lg	1024px	@media (min-width: 1024px) { ... }
    xl	1280px	@media (min-width: 1280px) { ... }
    2xl	1536px	@media (min-width: 1536px) { ... }
  - Example:
    <div className="my-10 sm:my-16 text-center"> if viewport smaller than 640px, my-16 will override my-10
    w-72 - width
    hidden md:block - display when more than medium side

- Using Flexbox
  "flex items-center justify-between"  - devide items and put them into both sides

- Using CSS Grid:
        <div className="grid grid-cols-2 grid-rows-3 gap-y-4">
        ---------
        <div className="grid h-screen grid-rows-[auto_1fr_auto]"> - devide screen into 3 lines
          {isLoading && <Loader />}
          <Header />
          <div className="overflow-scroll"> - scrllable div
            <main className="mx-auto max-w-3xl"> - content in the center with auto marging
              <Outlet />
            </main>
          </div>
          <CartOverview />
        </div>

- Styling Buttons: Element States and Transitions
    - Change color and text when hover:
    <Linkto="/menu" className="text-sm text-blue-500 hover:text-blue-600 hover:underline">
    
    - Transition colors with duration during hovering:
    <button className="inline-block rounded-full px-4 py-3 font-semibold uppercase tracking-wide text-stone-800 transition-colors duration-300 bg-yellow-400 hover:bg-yellow-300" />

    -  focus:bg-yellow-300 focus:outline-none focus:ring focus:ring-yellow-300 focus:ring-offset-2 - focus of button with ring around (offset - extended button out of the ring)
    - active:bg-slate-400 - change the color right after clicking
    - disabled:cursor-not-allowed disabled:bg-slate-600 - change cursor and color if button disabled
          
- Styling Form Elements
  - Checkbox:
  lassName="h-6 w-6 accent-yellow-400 focus:outline-none focus:ring focus:ring-yellow-400 focus:ring-offset-2"
  where 'accent-yellow-400' - checked color

- 304. Reusing Styles With @apply
  - in index.css:
  @layer components {
  .input {
    @apply w-full rounded-full border border-stone-200 px-4 py-2 text-sm transition-all duration-300 placeholder:text-stone-400 focus:outline-none focus:ring focus:ring-yellow-400 md:px-6 md:py-3;
  }
  }
  - in component:
  <input className="input" />

- 305. Reusing Styles With React Components;
  - Just create new component with defined classes:
    const LinkButton = ({ children, to }) => {
      return (
        <Link to={to} className="text-sm text-blue-500 hover:text-blue-600 hover:underline">
          {children}
        </Link>
      );
    };

  - 306. Absolute Positioning, z-index, and More
    - 'bg-slate-200/20' - 20 is oppacity
    - 'backdrop-blur-sm' - bluring
    - linear-gradient(theme(colors.stone.800) 0 0); - set Tailwind class inside CSS file
    - Loader example:
      <div className="absolute inset-0 flex items-center justify-center bg-slate-200/20 backdrop-blur-sm">
        <div className="loader"></div>
      </div>

- 307. Configuring Tailwind: Custom Font Family:
  - https://tailwindcss.com/docs/configuration

  - /fast-react-pizza/tailwind.config.js:
    export default {
      content: ['./index.html', './src/**/*.{js,ts,jsx,tsx}'],
      theme: {
        fontFamily: {
          pizza: 'Roboto Mono, monospace',
        },
        extend: {},
      },
      plugins: [],
    };
  - Usage in component:
     <header className="font-pizza>

  - extend: {}, - put here custom conf to extend, not replace:
        extend: {
          height: {
            screen: '100dvh', - dynemic viewport units
          },
        },
      result:
      className="h-screen" - 100dvh

- 308. Styling the Menu

  - <ul className='divide-y divide-stone-200'> - divide child items by gap with color
  - <img src={imageUrl} alt={name} className={`h-24 ${soldOut ? 'opacity-70 grayscale' : ''}`} /> - - make image with lower opacity and gray if sold out
  - <div className="flex grow flex-col"> - 'grow' the same as in CSS 'flex-grow: 1' - extend flex box as much as it can. to align buttons to right side unside the 'div'

- 309. Styling the Cart:
  - space between buttons (horizontal)
      <div className="mt-6 space-x-2">
        <Button to="/order/new" type="primary">
          Order pizzas
        </Button>
        <button>Clear cart</button>
      </div>

- 310. Styling the Order Form
  - className="grow" - extend box to the end (horizontally)
  - If we use flex boxes, we shouldn't use use 'width property'

  - favicon as emoji:
    - https://css-tricks.com/emoji-as-a-favicon/

- 311. Styling the Order Overview
  - wrap === {flex-wrap: wrap;} - CSS property sets the flex grow factor, which specifies how much of the flex container's positive free space, if any, should be assigned to the flex item's main size.
   <div className="flex flex-wrap items-center justify-between">

*****************************************************************************************************************
Section 24: Adding Redux and Advanced React Router
*****************************************************************************************************************

- 313. Modeling the "User" State With Redux Toolkit
  
  - Install Redux:
  npm i @reduxjs/toolkit react-redux

  - Add 'userSlice.js':
      const initialState = {
        username: '',
      };
      const userSlice = createSlice({
        name: 'user',
        initialState,
        reducers: {
          updateName(state, action) {
            state.username = action.payload;
          },
        },
      });
      export const { updateName } = userSlice.actions;
      export default userSlice.reducer;

  - Create store.js:
    const store = configureStore({
      reducer: {
        user: userReducer,
      },
    });

  - Add store to main jsx:
      ReactDOM.createRoot(document.getElementById('root')).render(
        <React.StrictMode>
          <Provider store={store}>
            <App />
          </Provider>
        </React.StrictMode>,
      );

  - Use 'user' state in components:
      const Username = () => {
        const username = useSelector((state) => state.user.username);
        ....

- 314. Reading and Updating the User State:
    - Update username in createUser component:
          function CreateUser() {
            const [username, setUsername] = useState('');
            const dispatch = useDispatch();
            const navigate = useNavigate();
            function handleSubmit(e) {
              e.preventDefault();
              if (!username) return;
              dispatch(updateName(username));
              navigate('/menu');
            }
            ...

  - Reuse state value in components just with:
      const username = useSelector((state) => state.user.username);

  - Auto fill input by value from state:
          <input
            ...
            defaultValue={username} - DO NOT USE 'value'!!!!
            ...
            required
          />

- 315. Modeling the "Cart" State

    - create cartSlice:
        const initialState = {
          cart: [],
        };
        const cartSlice = createSlice({
          name: 'cart',
          initialState,
          reducers: {
            addItem(state, action) {
              ....

    - Add cartRedicer to store:
        const store = configureStore({
          reducer: {
            user: userReducer,
            cart: cartReducer,
          },
        });

- 316. Adding Menu Items to the Cart

- 317. Building the Cart Overview With Redux Selectors

  - Get some calculated value from state. Place such function into slice file:
      export const getTotalCartQuantity = (state) =>
        state.cart.cart.reduce((sum, item) => sum + item.quantity, 0);
  - Add use it in component:
      function CartOverview() {
         const totalCartQuantity = useSelector(getTotalCartQuantity);
         ...

  - !!! in huge applications this approach is not used!!!!
  - Need to concider 'reselect' libraries

- 318. Building the Cart Page

- 319. Deleting Cart Items

- 320. Updating Cart Quantities

    - reusage reducer action in another one:
          deleteItem(state, action) {
            // payload = pizzaId
            state.cart = state.cart.filter((item) => item.pizzaId !== action.payload);
          },
          decreaseItemQuantity(state, action) {
            // payload = pizzaId
            const item = state.cart.find((item) => item.pizzaId === action.payload);
            item.quantity--;
            item.totalPrice = item.quantity * item.unitPrice;

            if (item.quantity === 0) cartSlice.caseReducers.deleteItem(state, action);
          },

- 321. Using the Cart for New Orders

  - update state from action function in component ('CreateOrder.jsx'). Do not overuse this.
      export async function action({ request }) {
        ....
        // Do NOT overuse
        store.dispatch(clearCart());
        return redirect(`/order/${newOrder.id}`);
      }

- 322. Redux Thunks With createAsyncThunk

    - Handle async function between dispatch and updating the state.

    - Update 'userSlice.js':
        const userSlice = createSlice({
          name: 'user',
          initialState,
          reducers: {
            updateName(state, action) {
              state.username = action.payload;
            },
          },
          extraReducers: (builder) =>
            builder
              .addCase(fetchAddress.pending, (state, action) => {
                state.status = 'loading';
              })
              .addCase(fetchAddress.fulfilled, (state, action) => {
                state.position = action.payload.position;
                state.address = action.payload.address;
                state.status = 'idle';
              })
              .addCase(fetchAddress.rejected, (state, action) => {
                state.status = 'error';
                state.error = action.error.message;
              }),
        });

    - usage in component:
        <button onClick={() => dispatch(fetchAddress())}>Get possition</button>

- 323. Integrating Geolocation:

        <div className="relative mb-5 flex flex-col gap-2 sm:flex-row sm:items-center">   --- relative, because child will be absolute
          <label className="sm:basis-40">Address</label>
          <div className="grow">
            <input
              className="input w-full"
              type="text"
              name="address"
              required
              disabled={isLoadingAddress}
              defaultValue={address}
            />
          </div>
          {addressStatus === 'error' && (
            <p className="mt-2 rounded-md bg-red-100 p-2 text-xs text-red-700">{errorAddress}</p>
          )}
          {!position.latitude && !position.longitude && (
            <span className="top=[3px] md:top=[5px] absolute right-[3px] z-50 md:right-[5px]">
              <Button
                type="small"
                onClick={(e) => {
                  e.preventDefault();    --- because we don't need submitt form (button inside form)
                  dispatch(fetchAddress());
                }}
                disabled={isLoadingAddress}
              >
                Get possition
              </Button>
            </span>
          )}
        </div>

- 324. Fetching Data Without Navigation: useFetcher

    - use it in component:
      const fetcher = useFetcher();
      useEffect(
        function () {
          if (!fetcher.data && fetcher.state === 'idle') fetcher.load('/menu'); ---- has 3 state: idle, loading, submitting
        },
        [fetcher],
      );
      ....
      <ul className="dive-stone-200 divide-y border-b border-t">
        {cart.map((item) => (
          <OrderItem
            item={item}
            key={item.pizzaId}
            isLoadingIngredients={fetcher.state === 'loading'}
            ingredients={fetcher?.data?.find((el) => el.id === item.pizzaId)?.ingredients ?? []}
          ></OrderItem>
        ))}
      </ul>

- 325. Updating Data Without Navigation

  - <Form method="POST"> - submit the form and rout to the different page
  - <fetcher.Form method='PATCH'> - submit the form and 're-validate' the current page

  - Implementation:
        {!priority && <UpdateOrder order={order} />}
        ----------
        const UpdateOrder = ({ order }) => {
          const fetcher = useFetcher();

          return (
            <fetcher.Form method="PATCH" className="text-right">
              <Button type="primary">Make priority</Button>
            </fetcher.Form>
          );
        };

        export default UpdateOrder;

        export async function action({ request, params }) {
          const data = { priority: true };
          await updateOrder(params.orderId, data);
          return null;
        }
        ---------
        {
          path: '/order/:orderId',
          element: <Order />,
          errorElement: <Error />,
          loader: orderLoader,
          action: updateOrderAction,
        },
      
*****************************************************************************************************************
Section 25: Setting Up Our Biggest Project + Styled Components
*****************************************************************************************************************

- 327. Application Planning:
  + General Structure:
    - Internal Hotel Management App
    - Customer-Facing Website to book stays (Later)
    - API
  + Requirements. Key featutes:
    - Authentification
    - Cabins
    - Bookings
    - Check In/Outdated
    - Guests
    - Dashboards
    - Settings
  + Pages:
    - Dashboards
    - Bookings
    - Cabins
    - Booking check in
    - App settings
    - User sign up
    - Login
    - Account settings

 - Client-side Rendering (CSR)
    + Vanila React
      - Used to build Single-Page App (SPAs)
      - All html is rendered on the client
      - All JS needs to be downloaded before apps starts running: bad for performance
      - One perfect use case: apps that are used 'internally' as tools companies, that are entirely hidden a login (this is exactly what we want to build in this project)

 - Server-side Rendering (SSR)
    + SSR Frameworks (Next.js, Remix)
      - Used for Multi-Page App (MPAs)
      - Some HTML is rendered in the server
      - More performance, as less JS needs to be downloaded
      - The React team is moving more and more in this direction

  + Techstack:
    + Rounting: ReactRouter (standard for React SPAs)
    + Styling: styled components (Veru popular for component scoped CSS, right inside JS)
    + Remote state management: React Query (The best way managing remote state with features like caching, auto re-fetching, pre-fetching, offline support. Alternative - SWR, RTK Query)
    + UI State management: Context API (There is almost no UI state needed in this app, so one simple useState will be enough. No need for Redux)
    + Form management: React Hook Form (Handling bigger forms can be a lot of work, such as manual state creation and error handling. Alibrary can simplify all this)
    + Other tools: React icons, React hot toast, Recharts, date-fns, Supabase

- 328. Setting Up the Project: "The Wild Oasis"

  1. npm create vite@4 (Vite install)
  2. npm i (Install all packages)
  3. npm install --save-dev vite-plugin-eslint eslint-config-react-app eslint (ESlint install)
  4. .eslintrc.json (create ESLint config file):
      {
          "extends": "react-app"
      }
  5. Update vite.config.js by:
      import eslint from 'vite-plugin-eslint';
      ...
      plugins: [....eslint()],
  6. Delete:
      - /assets
      - App.css
      - index.css
  7. In main.jsx delete import index.css 
  8. Recreate App.jsx
  9. Copy all files from /starter to /src

- 329. Introduction to Styled Components

    - install styled-components:
      npm i styled-components

    - use it in component:
            import styled from 'styled-components';
            const H1 = styled.h1`
              font-size: 30px;
              font-weight: 600;
              background-color: yellow;
            `;
            const Button = styled.button`
              font-size: 1.4rem;
              padding: 1.2rem 1.6rem;
              font-weight: 500;
              border: none;
              border-radius: 7px;
              background-color: purple;
              color: white;
              cursor: pointer;
              margin: 20px;
            `;
            const Input = styled.input`
              border: 1px solid #ddd;
              border-radius: 5px;
              padding: 0.8rem 1.2rem;
            `;
            const StyledApp = styled.div`
              background-color: orangered;
              padding: 20px;
            `
            const App = () => {
              return (
                <StyledApp>
                  <H1>The Wiled Oasis</H1>
                  <Button onClick={() => alert('Check in')}>Check in</Button>
                  <Button onClick={() => alert('Check out')}>Check out</Button>

                  <Input type="number" placeholder="Number of guests" />
                </StyledApp>
              );
            };
            
- 330. Global Styles With Styled Components

    - Create GlobalStyles.js:
        import { createGlobalStyle } from 'styled-components';
        const GlobalStyles = createGlobalStyle`
        :root {
          /* Indigo */
          --color-brand-50: #eef2ff;
          --color-brand-100: #e0e7ff;
          --color-brand-200: #c7d2fe;
          ...
    
    - able to add css vars in App.jsx. Add Sibling element GlobalStyles
            const Input = styled.input`
            border: 1px solid var(--color-grey-300);
            background-color: var(--color-grey-0);
            border-radius: var(--border-radius-sm);
            box-shadow: var(--shadow-sm);
            padding: 0.8rem 1.2rem;
          `;
            ....
          const App = () => {
            return (
              <>
                <GlobalStyles />
                <StyledApp>
                  <H1>The Wiled Oasis</H1>
                  <Button onClick={() => alert('Check in')}>Check in</Button>
                  <Button onClick={() => alert('Check out')}>Check out</Button>
                  <Input type="number" placeholder="Number of guests" />
                </StyledApp>
              </>
            );
          };

    - psedo classes like in common CSS:
          const Button = styled.button`
          ....
          &:hover {
            background-color: var(--color-brand-600);
          }
        `;

- 331. Styled Component Props and the "css" Function

      import styled, {css} from 'styled-components';
      const test = css`
        test-align: center;
        ${10 > 5 && "background-color: yellow"}
      `;
      const Heading = styled.h1`
        font-size: 30px;
        font-weight: 600;
        background-color: yellow;
        ${test}
      `;
      export default Heading;

      --------
        <Heading type="h3">Form</Heading> -  it will be <h1> element but modified style
        ....
        const Heading = styled.h1`
        ${(props) =>
          props.type === 'h1' &&    ----!!!
          css`
            font-size: 3rem;
            font-weight: 600;
          `}
        line-height: 1.4;
      `;
      -------
      <Heading as="h3">Form</Heading> -  it will be <h3> element
      ....
        const Heading = styled.h1`
        ${(props) =>
          props.as === 'h1' &&   ------!!!!
          css`
            font-size: 3rem;
            font-weight: 600;
          `}
        line-height: 1.4;
      `;

- 332. Building More Reusable Styled Components
          const App = () => {
            return (
              <>
                <GlobalStyles />
                <StyledApp>
                  <Row type="vertical">
                    <Row type="horizontal">
                      <Heading as="h1">The Wiled Oasis</Heading>
                      <div>
                        <Heading as="h2">Check in and out</Heading>
                        <Button onClick={() => alert('Check in')}>Check in</Button>
                        <Button onClick={() => alert('Check out')}>Check out</Button>
                      </div>
                    </Row>
                    <Row type="vertical">
                      <Heading as="h3">Form</Heading>
                      <form>
                        <Input type="number" placeholder="Number of guests" />
                        <Input type="number" placeholder="Number of guests" />
                      </form>
                    </Row>
                  </Row>
                </StyledApp>
              </>
            );
          };
          ------
          const Row = styled.div`
            display: flex;
            ${(props) =>
              props.type === 'horizontal' &&
              css`
                justify-content: space-between;
                align-items: center;
              `}
            ${(props) =>
              props.type === 'vertical' &&
              css`
                flex-direction: column;
                gap: 1.6rem;
              `}
          `;
          ----
          Row.defaultProps = {
            type: 'vertical',
          };

333. Setting Up Pages and Routes
  - install React Router:
  npm i react-router-dom@6

  - App.jsx:
      const App = () => {
        return (
          <>
            <GlobalStyles />
            <BrowserRouter>
              <Routes>
                <Route index element={<Navigate replace to="dashboard" />} />
                <Route path="dashboard" element={<Dashboard />} />
                <Route path="bookings" element={<Bookings />} />
                <Route path="cabins" element={<Cabins />} />
                <Route path="users" element={<Users />} />
                <Route path="settings" element={<Settings />} />
                <Route path="account" element={<Account />} />
                <Route path="login" element={<Login />} />
                <Route path="*" element={<PageNotFound />} />
              </Routes>
            </BrowserRouter>
          </>
        );
      };
      export default App;

- 334. Building the App Layout
      const App = () => {
        return (
          <>
            <GlobalStyles />
            <BrowserRouter>
              <Routes>
                <Route element={<AppLayout />}>
                  <Route index element={<Navigate replace to="dashboard" />} />
                  <Route path="dashboard" element={<Dashboard />} />
                  <Route path="bookings" element={<Bookings />} />
                  <Route path="cabins" element={<Cabins />} />
                  <Route path="users" element={<Users />} />
                  <Route path="settings" element={<Settings />} />
                  <Route path="account" element={<Account />} />
                </Route>
                <Route path="login" element={<Login />} />
                <Route path="*" element={<PageNotFound />} />
              </Routes>
            </BrowserRouter>
          </>
        );
      };
      ----
      const AppLayout = () => {
        return (
          <StyledAppLayout>
            <Header />
            <Sidebar />
            <Main>
              <Outlet />
            </Main>
          </StyledAppLayout>
        );
      };
      ----
      const Header = () => {
        return <StyledHeader>HEADER</StyledHeader>;
      };
      ----
      const Sidebar = () => {
        return <StyledSidebar>SIDEBAR</StyledSidebar>;
      };

- 335. Building the Sidebar and Main Navigation

    - Install react icons (https://react-icons.github.io/react-icons/):
    npm i react-icons

    import { HiOutlineCalendarDays, HiOutlineHome } from 'react-icons/hi2';
    ...
    const MainNav = () => {
    return (
      <nav>
        <NavList>
          <li>
            <StyledNavLink to="/dashboard">
              <HiOutlineHome />
              <span>Home</span>
            </StyledNavLink>
          </li>
          <li>
            <StyledNavLink to="/bookings">
              <HiOutlineCalendarDays />
              <span>Bookings</span>
            </StyledNavLink>
          </li>
        </NavList>
      </nav>
    );
  };
  -----
  const StyledNavLink = styled(NavLink)`` - style custom element

*****************************************************************************************************************
Section 26: Supabase Crash Course: Building a Back-End!
*****************************************************************************************************************

- 337. What is Supabase?
    - Supabase - PostgreSQL
    - Auto create database and API
    - No backend development needed
    - Perfect to get up and running
    - Not just API, but also user Authentication and file storage

- 338. Creating a New Database:
    - https://supabase.com/dashboard/project/tbdnqeequpkpxismudxc/building

- 339. Modeling Application State:
  - Tables:
    - GUESTS (id, email...)
    - CABIN (id, name, ...)
    - BOOKING (id, guestId, cabinId, ...) - guestId, cabinId - forein keys

- 340. Creating Tables:
    - cabins
    - guests
    - settings

- 341. Relationships Between Tables
    + 'bookings' table wit relations to cabins and guests

- 342. Adding Security Policies (RLS)
    - Supabase has api to run query all types with provided code snipets
    - Go to 'API Docs', choose table and query. Copy command and execute

    - Go to 'Authentification' - 'Policies'
    - Greate new Policy from SELECT template with allow read access for all user. Do it for all tables

- 343. Connecting Supabase With Our React App
    - Install lib:
    npm install @supabase/supabase-js

- 344. Setting Up Storage Buckets
  - Create 2 buckets in stirage:
    - avatars
    - cabin-images
  - Coppy images from /src/data/cabins to cabin-images
  
  - Copy URL for one image sand create to test:
        <img src="https://tbdnqeequpkpxismudxc.supabase.co/storage/v1/object/public/cabin-images/cabin_001.jpg" />
  - Copy this URL also to the table 'cabins'.'imageUrl'

*****************************************************************************************************************
Section 27: React Query: Managing Remote State
*****************************************************************************************************************

- 346. What is React Query?
    - Powerful lib for managing remote (server) state
    - Many features that allow us to write a lot less code, while also making the UX a lot better:
        + Data is stored in a cache
        + Automatic loading and error states
        + Automatic re-fetching to keep state synched
        + Pre-fetching
        + Easy remote state mutation (updating)
        + Offline support
    - Needed because remote state is fundamentally different from regular (UI) state

- 347. Setting Up React Query

  - npm i @tanstack/react-query@4
  - npm i @tanstack/react-query-devtools@4   ---- dev tools
  - Docs: https://tanstack.com/query/latest/docs/framework/react/overview#motivation

      const queryClient = new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 60 * 100,
          },
        },
      });

      const App = () => {
        return (
          <QueryClientProvider client={queryClient}>
            <ReactQueryDevtools />
            <GlobalStyles />
            <BrowserRouter>
              <Routes>
                <Route element={<AppLayout />}>
                  <Route index element={<Navigate replace to="dashboard" />} />
                  <Route path="dashboard" element={<Dashboard />} />
                  <Route path="bookings" element={<Bookings />} />
                  <Route path="cabins" element={<Cabins />} />
                  <Route path="users" element={<Users />} />
                  <Route path="settings" element={<Settings />} />
                  <Route path="account" element={<Account />} />
                </Route>
                <Route path="login" element={<Login />} />
                <Route path="*" element={<PageNotFound />} />
              </Routes>
            </BrowserRouter>
          </QueryClientProvider>
        );
      };

- 349. Fetching Cabin Data
    - Install lib to manupulate with dates
    npm i date-fns

    - Fetching data in componenmt:
      const CabinTable = () => {
        const {
          isLoading,
          data: cabins,
          isError,
        } = useQuery({
          queryKey: ['cabin'], --- Key of data to use it across the app via Query
          queryFn: getCabins, ---- async function from apiCabins
        });
        if (isLoading) return <Spinner />;
        return (
          <Table role="table">
            <TableHeader role="row">
              <div></div>
              <div>Cabin</div>
              <div>Capacity</div>
              <div>Price</div>
              <div>Discount</div>
              <div></div>
            </TableHeader>
            {cabins.map((cabin) => (
              <CabinRow cabin={cabin} key={cabin.id} />
            ))}
          </Table>
        );
      };
      ----
      export async function getCabins() {
        let { data, error } = await supabase.from('cabins').select('*');
        if (error) {
          console.error(error);
          throw new Error('Cabins could not be loaded');
        }
        return data;
      }

- 350. Mutations: Deleting a Cabin

        export async function deleteCabin(id) {
          const { data, error } = await supabase.from('cabins').delete().eq('id', id);

          if (error) {
            console.error(error);
            throw new Error('Cabin could not be deleted');
          }

          return data;
        }

        - Supabase code was taken from: https://supabase.com/dashboard/project/tbdnqeequpkpxismudxc/api?resource=cabins

        - Need to add new security policy to Supabase to allow us delete rows, not only select: https://supabase.com/dashboard/project/tbdnqeequpkpxismudxc/auth/policies

        - The same next expressions, because calling the same value as provided:
            + mutationFn: (id) => deleteCabin(id)
            + mutationFn: deleteCabin

        const CabinRow = ({ cabin }) => {
          const { id: cabinId, name, maxCapacity, regularPrice, discount, image } = cabin;

          const queryClient = useQueryClient();

          const { isLoading: isDeleting, mutate } = useMutation({
            // mutationFn: (id) => deleteCabin(id),
            mutationFn: deleteCabin,   ---- calling func from apiCabins.js
            onSuccess: () => {
              alert('Cabin successfully deleted');
              queryClient.invalidateQueries({ queryKey: ['cabins'] }); --- invalidate cash for re-loading page with deleted row
            },
            onError: (err) => alert(err.message), --- handle errors
          });

          return (
            <TableRow role="row">
              <Img src={image} />
              <Cabin>{name}</Cabin>
              <div>Fits up to {maxCapacity} guests</div>
              <Price>{formatCurrency(regularPrice)}</Price>
              <Discount>{formatCurrency(discount)}</Discount>
              <button onClick={() => mutate(cabinId)} disabled={isDeleting}>
                Delete
              </button>
            </TableRow>
          );
        };

- 351. Displaying Toasts (Notifications)
  - Installation:
   npm i react-hot-toast

  - Documentation:
   https://react-hot-toast.com/

  - Add toaster config to App.jsx:
      const App = () => {
        return (
          <QueryClientProvider client={queryClient}>
            <ReactQueryDevtools />
            <GlobalStyles />
            <BrowserRouter>
      ....
            </BrowserRouter>
            <Toaster
              position="top-center"
              gutter={12}
              continerStyle={{ margin: '8px' }}
              toastOptions={{
                success: {
                  duration: 3000,
                },
                error: {
                  duration: 5000,
                },
                style: {
                  fontSize: '16px',
                  maxWidth: '500px',
                  padding: '16px 24px',
                  backgroundColor: 'var(--color-grey-0)',
                  color: 'var(--color-grey-700)',
                },
              }}
            />
          </QueryClientProvider>
        );
      };

  - Use it:
      const { isLoading: isDeleting, mutate } = useMutation({
        // mutationFn: (id) => deleteCabin(id),
        mutationFn: deleteCabin,
        onSuccess: () => {
          toast.success('Cabin successfully deleted');
          queryClient.invalidateQueries({ queryKey: ['cabins'] });
        },
        onError: (err) => toast.error(err.message),
      });

- 352. Introducing Another Library: React Hook Form

  - Create form component:
  the-wild-oasis/src/features/cabins/CreateCabinForm.jsx

  - Install lib:
  npm i react-hook-form@7

  - Modify form component:
        function CreateCabinForm() {
          const { register, handleSubmit } = useForm();   ---- add new hook

          function onSubmit(data) {   ---- create function for handle submit
            console.log(data);
          }

          return (
            <Form onSubmit={handleSubmit(onSubmit)}>
              <FormRow>
                <Label htmlFor="name">Cabin name</Label>
                <Input type="text" id="name" {...register('name')} />   ----- add register function for each field
              </FormRow>

              <FormRow>
                <Label htmlFor="maxCapacity">Maximum capacity</Label>
                <Input type="number" id="maxCapacity" {...register('maxCapacity')} />
              </FormRow>

          ..........
            </Form>

- 353. Creating a New Cabin

  - Create the new 'Insert' and 'Update' polices for cabin table in supabase for all users.

  - Copy JS code in section 'API Docs' -> 'cabins' -> 'Insert a row':
      const { data, error } = await supabase
      .from('cabins')
      .insert([{ some_column: 'someValue', other_column: 'otherValue' }])
      .select();

  - So copy and modify previous code to services/apiCabins.js:
        export async function createCabin(newCabin) {
        const { data, error } = await supabase.from('cabins').insert([newCabin]).select();
        if (error) {
          console.error(error);
          throw new Error('Cabin could not be created');
        }
      }

  - Modify CreateCabinForm component:
          function CreateCabinForm() {
          const queryClient = useQueryClient();   ---- use it

          const { mutate, isLoading: isCreating } = useMutation({   ---- use mutation hook
            mutationFn: createCabin,
            onSuccess: () => {
              toast.success('New cabin successfully created');
              queryClient.invalidateQueries({ queryKey: ['cabins'] });    ---- invalidate component to display new cabit in table
              reset();                                                    ---- to reset the form after successful submit
            },
            onError: (err) => toast.error(err.message),
          });

          const { register, handleSubmit, reset } = useForm();

          function onSubmit(data) {
            mutate(data);
          }

          return (
            <Form onSubmit={handleSubmit(onSubmit)}>
            .....
            <Button disabled={isCreating}>Add cabin</Button>
            .....

- 354. Handling Form Errors

  - Make scroll only for AppLayout.jsx (scroll main contetnt except navver and header)
      const Main = styled.main`
      ...
      overflow: scroll;
    `;

  - Make field required in form:
      <FormRow>
        <Label htmlFor="name">Cabin name</Label>
        <Input
          type="text"
          id="name"
          {...register('name', { required: 'This field is required' })}  ---- add 'required' prop
        />
      </FormRow>

  - Make validation on min value:
      <FormRow>
        <Label htmlFor="regularPrice">Regular price</Label>
        <Input
          type="number"
          id="regularPrice"
          {...register('regularPrice', {
            required: 'This field is required',
            min: {
              value: 1,
              message: 'Price should be at least 1',
            },
          })}
        />
      </FormRow>

  - Make custom validation:
      const { register, handleSubmit, reset, getValues } = useForm();   --- use getValues to get value from other fields
        .....
      <FormRow>
        <Label htmlFor="discount">Discount</Label>
        <Input
          type="number"
          id="discount"
          defaultValue={0}
          {...register('discount', {
            required: 'This field is required',
            validate: (value) =>
              value <= getValues().regularPrice || 'Discount should be less than regular price',
          })}
        />
      </FormRow>

  - Make display erro for particular field:
        const { register, handleSubmit, reset, getValues, formState } = useForm();
        const { errors } = formState;
        ....
        <FormRow>
          <Label htmlFor="name">Cabin name</Label>
          <Input
            type="text"
            id="name"
            {...register('name', { required: 'This field is required' })}
          />
          {errors?.name?.message && <Error>{errors.name.message}</Error>}
        </FormRow>

  - Create own FormRow component:
      const FormRow = ({ label, error, children }) => {
        return (
          <StyledFormRow>
            {label && <Label htmlFor={children.props.id}>{label}</Label>}
            {children}
            {error && <Error>{error}</Error>}
          </StyledFormRow>
        );
      };

  - And use in in CreateCabinForm:
      <Form onSubmit={handleSubmit(onSubmit, onError)}>
        <FormRow label="Cabin name" error={errors?.name?.message}>
          <Input
            type="text"
            id="name"
            disabled={isCreating}
            {...register('name', { required: 'This field is required' })}
          />
        </FormRow>
        ....

- 355. Uploading Images to Supabase

  - Configure supabase storage to upload image.
    - Set up policy: 'Storage' -> 'Storage policies' -> 'New policy' -> 'Full customization' -> enable all operations
    - Read how to upload file into storage: https://supabase.com/docs/guides/storage/uploads/standard-uploads and grep code snippet

  - Add type=file attr to styled component:
      const FileInput = styled.input.attrs({type: 'file'})`  ------ this one
        font-size: 1.4rem;
        border-radius: var(--border-radius-sm);

        &::file-selector-button {
          font: inherit;
          font-weight: 500;
          padding: 0.8rem 1.2rem;
          margin-right: 1.2rem;
          border-radius: var(--border-radius-sm);
          border: none;
          color: var(--color-brand-50);
          background-color: var(--color-brand-600);
          cursor: pointer;
          transition: color 0.2s, background-color 0.2s;

          &:hover {
            background-color: var(--color-brand-700);
          }
        }
      `;

  - Use in in create table form:
      function onSubmit(data) {
        mutate({ ...data, image: data.image[0] });
        console.log(data);
      }
      ....
      <FormRow label="Cabin photo">
        <FileInput
          id="image"
          accept="image/*"
          {...register('image', { required: 'This field is required' })}
        />
      </FormRow>

  - Add API to upload images to storage and add new cabin record with link to storage:
        export async function createCabin(newCabin) {
          const imageName = `${Math.random()}-${newCabin.image.name}`.replaceAll('/', '');
          const imagePath = `${supabaseUrl}/storage/v1/object/public/cabin-images/${imageName}`;
          // https://tbdnqeequpkpxismudxc.supabase.co/storage/v1/object/public/cabin-images/cabin_001.jpg

          // 1. Create cabin
          const { data, error } = await supabase
            .from('cabins')
            .insert([{ ...newCabin, image: imagePath }])
            .select();

          if (error) {
            console.error(error);
            throw new Error('Cabin could not be created');
          }

          // 2. Upload image

          const { error: storageError } = await supabase.storage
            .from('cabin-images')
            .upload(imageName, newCabin.image);

          // 3. Delete the cabin IF there was an error uploading file
          if (storageError) {
            await supabase.from('cabins').delete().eq('id', data.id);
            console.error(storageError);
            throw new Error('Cabin image could not be uploaded and the cabin was not created');
          }

          return data;
        }

- 356. Editing a Cabin
    - see code

- 357. Abstracting React Query Into Custom Hooks
    - reset() function could use in diffrent place:
    not oly here:
    const { mutate: editCabin, isLoading: isEditing } = useMutation({
      mutationFn: ({ newCabinData, id }) => createEditCabin(newCabinData, id),
      onSuccess: () => {
        toast.success('Cabin successfully edited');
        queryClient.invalidateQueries({ queryKey: ['cabins'] });
        reset();
      },
      onError: (err) => toast.error(err.message),
    }); 
    BUT ALSO:
     else createCabin({ ...data, image }, { onSuccess: (data) => reset() });

- 358. Duplicating Cabins
- 359. Fetching Applications Settings
    - Create custom hook:
    import { useQuery } from '@tanstack/react-query';
    import { getSettings } from '../../services/apiSettings';
    export function useSettings() {
      const {
        isLoading,
        error,
        data: settings,
      } = useQuery({
        queryKey: ['settings'],
        queryFn: getSettings,       ------ func from settings api
      });

      return { isLoading, error, settings };
    }

    - Use this hook in component to fetch data from DB:
    function UpdateSettingsForm() {
    const {
      isLoading,
      settings: { minBookingLenght, maxBookingLenght, maxGuestsPerBooking, breakfastPrice } = {},   ------ assign to emty object to avoid error during first rendering
    } = useSettings();
    if (isLoading) return <Spinner />;
    return (
      <Form>
        <FormRow label="Minimum nights/booking">
          <Input type="number" id="min-nights" defaultValue={minBookingLenght} />
        </FormRow>
        <FormRow label="Maximum nights/booking">
          <Input type="number" id="max-nights" defaultValue={maxBookingLenght} />
        </FormRow>
        <FormRow label="Maximum guests/booking">
          <Input type="number" id="max-guests" defaultValue={maxGuestsPerBooking} />
        </FormRow>
        <FormRow label="Breakfast price">
          <Input type="number" id="breakfast-price" defaultValue={breakfastPrice} />
        </FormRow>
      </Form>
    );
  }
  export default UpdateSettingsForm;

- 360. Updating Application Settings

*****************************************************************************************************************
Section 28: Advanced React Patterns
*****************************************************************************************************************

- 362. An Overview of Reusability in React

  - I need to reuse:
    1. UI
      - Components and props (Use props as a component API, to enable custom behavior. Can be stateless, stateful or structural components)
      - Children prop (To customize the component's content)
    2. Stateful Logic (logic with hooks)

  - New patterns:
    - Render props pattern (for complete control over what the component renders, by passing in a function that tells the component what to render. Was more common before hooks, but still useful)
    - Compound component pattern (For very self-contained components that need/want to manage their own state. Compound components are like fancy super-components)

- 363. Setting Up an Example
  - Project:
    https://codesandbox.io/p/sandbox/react-render-props-starter-7tomkd?file=%2Fsrc%2Findex.js

- 364. The Render Props Pattern
  - usage a 'render' function as a prop:
          function List({ title, items, render }) {
            const [isOpen, setIsOpen] = useState(true);
            const [isCollapsed, setIsCollapsed] = useState(false);
            const displayItems = isCollapsed ? items.slice(0, 3) : items;
            function toggleOpen() {
              setIsOpen((isOpen) => !isOpen);
              setIsCollapsed(false);
            }
            return (
              <div className="list-container">
                <div className="heading">
                  <h2>{title}</h2>
                  <button onClick={toggleOpen}>
                    {isOpen ? <span>&or;</span> : <span>&and;</span>}
                  </button>
                </div>
                {isOpen && <ul className="list">{displayItems.map(render)}</ul>}

                <button onClick={() => setIsCollapsed((isCollapsed) => !isCollapsed)}>
                  {isCollapsed ? `Show all ${items.length}` : "Show less"}
                </button>
              </div>
            );
          }
          .....
          export default function App() {
            return (
              <div>
                <h1>Render Props Demo</h1>

                <div className="col-2">
                  <List
                    title="Products"
                    items={products}
                    render={(product) => (
                      <ProductItem key={product.productName} product={product} />
                    )}
                  />

                  <List
                    title="Companies"
                    items={companies}
                    render={(company) => (
                      <CompanyItem
                        key={company.companyName}
                        company={company}
                        defaultVisibility={false}
                      />
                    )}
                  />
                </div>
              </div>
            );
          } 

- 365. A Look at Higher-Order Components (HOC)

        function ProductList({ title, items }) {
          return (
            <ul className="list">
              {items.map((product) => (
                <ProductItem key={product.productName} product={product} />
              ))}
            </ul>
          );
        }
        const ProductListWithToggles = withToggles(ProductList);
        export default function App() {
          return (
            <div>
              <h1>Render Props Demo</h1>
              <div className="col-2">
                <ProductList title="Products HOC" items={products} />
                <ProductListWithToggles title="Products HOC" items={products} />
              </div>
            </div>
          );
        }
        -------------
        export default function withToggles(WrappedComponent) {
          return function List(props) {
            const [isOpen, setIsOpen] = useState(true);
            const [isCollapsed, setIsCollapsed] = useState(false);
            const displayItems = isCollapsed ? props.items.slice(0, 3) : props.items;
            function toggleOpen() {
              setIsOpen((isOpen) => !isOpen);
              setIsCollapsed(false);
            }
            return (
              <div className="list-container">
                <div className="heading">
                  <h2>{props.title}</h2>
                  <button onClick={toggleOpen}>
                    {isOpen ? <span>&or;</span> : <span>&and;</span>}
                  </button>
                </div>
                {isOpen && <WrappedComponent {...props} items={displayItems} />}

                <button onClick={() => setIsCollapsed((isCollapsed) => !isCollapsed)}>
                  {isCollapsed ? `Show all ${props.items.length}` : "Show less"}
                </button>
              </div>
            );
          };
        }

- 366. The Compound Component Pattern
  - Project:
    https://codesandbox.io/p/sandbox/react-compound-components-starter-o0ofud?file=%2Fsrc%2Findex.js

    Exaple:
      <Counter
        iconIncrease="+"
        iconDecrease="-"
        label="My NOT so flexible counter"
        hideLabel={false}
        hideIncrease={false}
        hideDecrease={false}
      />
      --------
      <Counter>
        <Counter.Label>My super flexible counter</Counter.Label>
        <Counter.Count />
        <Counter.Decrease icon="-" />
        <Counter.Increase icon="+" />
      </Counter>
      ------
      import { createContext, useState, useContext } from "react";
      // 1. Create context
      const CounterContext = createContext();
      // 2. Create parent component
      function Counter({ children }) {
        const [count, setCount] = useState(0);
        const increase = () => setCount((c) => c + 1);
        const decrease = () => setCount((c) => c - 1);
        return (
          <CounterContext.Provider value={{ count, increase, decrease }}>
            <span>{children}</span>
          </CounterContext.Provider>
        );
      }
      // 3. Create child component to help implementing the common tasks
      function Count() {
        const { count } = useContext(CounterContext);
        return <span>{count}</span>;
      }
      function Label({ children }) {
        return <span>{children}</span>;
      }
      function Increase({ icon }) {
        const { increase } = useContext(CounterContext);
        return <button onClick={increase}>{icon}</button>;
      }
      function Decrease({ icon }) {
        const { decrease } = useContext(CounterContext);
        return <button onClick={decrease}>{icon}</button>;
      }
      // 4. Add child components as properties to parent component
      Counter.Count = Count;
      Counter.Label = Label;
      Counter.Increase = Increase;
      Counter.Decrease = Decrease;
      export default Counter;

- 367. Building a Modal Window Using a React Portal:

    - Create modal window inside particular element (in our case 'body' element)
      const Modal = ({ children, onClose }) => {
        return createPortal(
          <Overlay>
            <StyledModal>
              <Button onClick={onClose}>
                <HiXMark />
              </Button>
              <div>{children}</div>
            </StyledModal>
          </Overlay>,
          document.body,
        );
      };

- 368. Converting the Modal to a Compound Component

        const AddCabin = () => {
          return (
            <Modal>
              <Modal.Open opens="cabin-form">
                <Button>Add new cabin</Button>
              </Modal.Open>
              <Modal.Window name="cabin-form">
                <CreateCabinForm />
              </Modal.Window>

              <Modal.Open opens="table">
                <Button>Show table</Button>
              </Modal.Open>
              <Modal.Window name="table">
                <CabinTable />
              </Modal.Window>
            </Modal>
          );
        };
        -----------
        const ModalContext = createContext();

        const Modal = ({ children }) => {
          const [openName, setOpenName] = useState('');

          const close = () => setOpenName('');
          const open = setOpenName;

          return (
            <ModalContext.Provider value={{ openName, close, open }}>{children}</ModalContext.Provider>
          );
        };

        const Open = ({ children, opens: opensWindowName }) => {
          const { open } = useContext(ModalContext);

          return cloneElement(children, { onClick: () => open(opensWindowName) });
        };

        const Window = ({ children, name }) => {
          const { openName, close } = useContext(ModalContext);
          if (name !== openName) return null;

          return createPortal(
            <Overlay>
              <StyledModal>
                <Button onClick={close}>
                  <HiXMark />
                </Button>
                <div>{cloneElement(children, { onCloseModal: close })}</div>
              </StyledModal>
            </Overlay>,
            document.body,
          );
        };

        Modal.Open = Open;
        Modal.Window = Window;

        export default Modal;

        *****
        To pass props can be used:
        cloneElement(children, { onClick: () => open(opensWindowName) });

- 369. Detecting a Click Outside the Modal

      const Window = ({ children, name }) => {
        const { openName, close } = useContext(ModalContext);
        const ref = useOutsideClick(close);   ------ !!!!!
        if (name !== openName) return null;
        return createPortal(
          <Overlay>
            <StyledModal ref={ref}>    ------ !!!!!
              <Button onClick={close}>
                <HiXMark />
              </Button>
              <div>{cloneElement(children, { onCloseModal: close })}</div>
            </StyledModal>
          </Overlay>,
          document.body,
        );
      };
      ----------
      export function useOutsideClick(handler, listenCapturing = true) {
        const ref = useRef();
        useEffect(
          function () {
            function handleClick(e) {
              if (ref.current && !ref.current.contains(e.target)) handler();
            }
            document.addEventListener('click', handleClick, listenCapturing);  ----- listenCapturing=true to avoid imidiate closing right after model opening (just listen event in capturing phase, not in bubling)
            return () => document.removeEventListener('click', handleClick, listenCapturing);  ---- the same
          },
          [handler, listenCapturing],
        );
        return ref;
      }

- 370. Confirming Cabin Deletions

          <TableRow role="row">
            <Img src={image} />
            <Cabin>{name}</Cabin>
            <div>Fits up to {maxCapacity} guests</div>
            <Price>{formatCurrency(regularPrice)}</Price>
            {discount ? <Discount>{formatCurrency(discount)}</Discount> : <span>&mdash;</span>}
            <div>
              <button onClick={handleDuplicate} disabled={isCreating}>
                <HiSquare2Stack />
              </button>

              <Modal>
                <Modal.Open opens="edit">
                  <button>
                    <HiPencil />
                  </button>
                </Modal.Open>
                <Modal.Window name="edit">
                  <CreateCabinForm cabinToEdit={cabin} />
                </Modal.Window>

                <Modal.Open opens="delete">
                  <button>
                    <HiTrash />
                  </button>
                </Modal.Open>
                <Modal.Window name="delete">
                  <ConfirmDelete
                    resourceName="cabins"
                    disabled={isDeleting}
                    onConfirm={() => deleteCabin(cabinId)}
                  />
                </Modal.Window>
              </Modal>
            </div>
          </TableRow>
          ----------
      function ConfirmDelete({ resourceName, onConfirm, disabled, onCloseModal }) {
        return (
          <StyledConfirmDelete>
            <Heading as="h3">Delete {resourceName}</Heading>
            <p>
              Are you sure you want to delete this {resourceName} permanently? This action cannot be
              undone.
            </p>

            <div>
              <Button variation="secondary" disabled={disabled} onClick={onCloseModal}>
                Cancel
              </Button>
              <Button variation="danger" disabled={disabled} onClick={onConfirm}>
                Delete
              </Button>
            </div>
          </StyledConfirmDelete>
        );
      }

- 371. Building a Reusable Table

  - See all implementation in commit

        <Table columns="0.6fr 1.8fr 2.2fr 1fr 1fr 1fr">
          <Table.Header>
            <div></div>
            <div>Cabin</div>
            <div>Capacity</div>
            <div>Price</div>
            <div>Discount</div>
            <div></div>
          </Table.Header>
          {cabins.map((cabin) => (
            <CabinRow cabin={cabin} key={cabin.id} />
          ))}
        </Table>
        ---------
        const TableContext = createContext();
        function Table({ columns, children }) {
          return (
            <TableContext.Provider value={{ columns }}>
              <StyledTable role="table">{children}</StyledTable>
            </TableContext.Provider>
          );
        }
        function Header({ children }) {
          const { columns } = useContext(TableContext);
          return (
            <StyledHeader role="row" columns={columns} as="header"> --- 'as' make element as 'header'
              {children}
            </StyledHeader>
          );
        }
        function Row({ children }) {
          const { columns } = useContext(TableContext);
          return (
            <StyledRow role="row" columns={columns}>
              {children}
            </StyledRow>
          );
        }
        function Body({ children }) {}
        Table.Header = Header;
        Table.Row = Row;
        Table.Body = Body;
        Table.Footer = Footer;
        export default Table;

- 372. Applying the Render Props Pattern

      function Body({ data, render }) {
        if (!data.length) return <Empty>No data to show at the moment</Empty>;
        return <StyledBody>{data.map(render)}</StyledBody>;
      }
      ----
      <Table columns="0.6fr 1.8fr 2.2fr 1fr 1fr 1fr">
        <Table.Header>
          <div></div>
          <div>Cabin</div>
          <div>Capacity</div>
          <div>Price</div>
          <div>Discount</div>
          <div></div>
        </Table.Header>
        <Table.Body data={cabins} render={(cabin) => <CabinRow cabin={cabin} key={cabin.id} />} />
        {/* {cabins.map((cabin) => (
          <CabinRow cabin={cabin} key={cabin.id} />
        ))} */}
      </Table>

- 373. Building a Reusable Context Menu

  function handleClick(e) {
    const rect = e.target.closest('button').getBoundingClientRect();   --- get coordinates of clickable element
    console.log(rect);

    openId === '' || openId !== id ? open(id) : close();
  }

  Menus.jsx
  ----------------
  const MenusContext = createContext();
  const Menus = ({ children }) => {
    const [openId, setOpenId] = useState('');
    const [position, setPosition] = useState(null);
    const close = () => setOpenId('');
    const open = setOpenId;
    return (
      <MenusContext.Provider value={{ openId, close, open, position, setPosition }}>
        {children}
      </MenusContext.Provider>
    );
  };
  function Toggle({ id }) {
    const { openId, close, open, position, setPosition } = useContext(MenusContext);
    function handleClick(e) {
      const rect = e.target.closest('button').getBoundingClientRect();
      setPosition({
        x: window.innerWidth - rect.width - rect.x,
        y: rect.y + rect.height + 8,
      });

      openId === '' || openId !== id ? open(id) : close();
    }
    return (
      <StyledToggle onClick={handleClick}>
        <HiEllipsisVertical />
      </StyledToggle>
    );
  }
  function List({ id, children }) {
    const { openId, position, close } = useContext(MenusContext);
    const ref = useOutsideClick(close);

    if (openId !== id) return null;
    return createPortal(
      <StyledList position={position} ref={ref}>
        {children}
      </StyledList>,
      document.body,
    );
  }
  function Button({ children, icon, onClick }) {
    const { close } = useContext(MenusContext);

    function handleClick() {
      onClick?.();
      close();
    }
    return (
      <li>
        <StyledButton onClick={handleClick}>
          {icon}
          <span>{children}</span>
        </StyledButton>
      </li>
    );
  }
  Menus.Menu = Menu;
  Menus.Toggle = Toggle;
  Menus.List = List;
  Menus.Button = Button;
  export default Menus;

  -------------
        return (
        <Table.Row>
          <Img src={image} />
          <Cabin>{name}</Cabin>
          <div>Fits up to {maxCapacity} guests</div>
          <Price>{formatCurrency(regularPrice)}</Price>
          {discount ? <Discount>{formatCurrency(discount)}</Discount> : <span>&mdash;</span>}
          <div>
            <Modal>
              <Menus.Menu>
                <Menus.Toggle id={cabinId} />
                <Menus.List id={cabinId}>
                  <Menus.Button icon={<HiSquare2Stack />} onClick={handleDuplicate}>
                    Duplicate
                  </Menus.Button>

                  <Modal.Open opens="edit">
                    <Menus.Button icon={<HiPencil />}>Edit</Menus.Button>
                  </Modal.Open>

                  <Modal.Open opens="delete">
                    <Menus.Button icon={<HiTrash />}>Delete</Menus.Button>
                  </Modal.Open>
                </Menus.List>

                <Modal.Window name="edit">
                  <CreateCabinForm cabinToEdit={cabin} />
                </Modal.Window>

                <Modal.Window name="delete">
                  <ConfirmDelete
                    resourceName="cabins"
                    disabled={isDeleting}
                    onConfirm={() => deleteCabin(cabinId)}
                  />
                </Modal.Window>
              </Menus.Menu>
            </Modal>
          </div>
        </Table.Row>
      );

*****************************************************************************************************************
Section 29: [Optional] Implementing More Features: Authentication, Dark Mode, Dashboard, etc
*****************************************************************************************************************

- 375. Client-Side Filtering: Filtering Cabins

    - Use URL params for this:
    const CabinTableOperations = () => {
      return (
        <TableOperations>
          <Filter
            filterField={'discount'}
            options={[
              { value: 'all', label: 'All' },
              { value: 'no-discount', label: 'No discount' },
              { value: 'with-discount', label: 'With discount' },
            ]}
          />
        </TableOperations>
      );
    };
    -------
    const Filter = ({ filterField, options }) => {
      const [searchParams, setSearchParams] = useSearchParams();
      const currentFilter = searchParams.get(filterField) || options.at(0).value;

      function handleClick(value) {
        searchParams.set(filterField, value);
        setSearchParams(searchParams);
      }

      return (
        <StyledFilter>
          {options.map((option) => (
            <FilterButton
              key={option.value}
              onClick={() => handleClick(option.value)}
              active={option.value === currentFilter}
              disabled={option.value === currentFilter}
            >
              {option.label}
            </FilterButton>
          ))}
        </StyledFilter>
      );
    };

- 376. Client-Side Sorting: Sorting Cabins

  - other all props can be passed with spread operator:
  const Select = ({ options, value, ...props }) => { ------!!!
    return (
      <StyledSelect value={value} {...props}>   -----!!!!
        {options.map((option) => (
          <option value={option.value} key={option.value}>
            {option.label}
          </option>
        ))}
      </StyledSelect>
    );
  };
  ------
  const SortBy = ({ options }) => {
    const [searchParams, setSearchParams] = useSearchParams();
    const sortBy = searchParams.get('sortBy') || '';
    function handleChange(e) {
      searchParams.set('sortBy', e.target.value);
      setSearchParams(searchParams);
    }
    return <Select options={options} type="white" value={sortBy} onChange={handleChange}></Select>;
  };
  -----
  // 2. SORT
  const sortBy = searchParams.get('sortBy') || 'startDate-asc';
  const [field, direction] = sortBy.split('-');
  const modifier = direction === 'asc' ? 1 : -1;
  const sortedCabins = filteredCabins.sort((a, b) => (a[field] - b[field]) * modifier) ;
  -----
        <SortBy
        options={[
          { value: 'name-asc', label: 'Sort by name (A-Z)' },
          { value: 'name-desc', label: 'Sort by name (Z-A)' },
          { value: 'regularPrice-asc', label: 'Sort by price (low first)' },
          { value: 'regularPrice-desc', label: 'Sort by price (high first)' },
          { value: 'maxCapacity-asc', label: 'Sort by capacity (low first)' },
          { value: 'maxCapacity-desc', label: 'Sort by capacity (high first)' },
        ]}
      />

- 377. Building the Bookings Table

  - Create data in supabase for 'guests' and 'bookings' tables

  - To get data from table and related records by foreign keys from other tables:
      export async function getBookings() {
        // const { data, error } = await supabase.from('bookings').select('*, cabins(*), guests(*)');
        const { data, error } = await supabase
          .from('bookings')
          .select(
            'id, created_at, startDate, endDate, numNights, numGuests, status, totalPrice, cabins(name), guests(fullName, email)',
          );
        if (error) {
          console.error(error);
          throw new Error('Bookings could not be loaded');
        }
        return data;
      }

- 378. Uploading Sample Data

    - Added 'Uploder' component to upload test data 

- 379. API-Side Filtering: Filtering Bookings

  - apiBookings.js:
      export async function getBookings({ filter, sortBy }) {
        // const { data, error } = await supabase.from('bookings').select('*, cabins(*), guests(*)');
        let query = supabase
          .from('bookings')
          .select(
            'id, created_at, startDate, endDate, numNights, numGuests, status, totalPrice, cabins(name), guests(fullName, email)',
          );
        // FILTER
        if (filter !== null) query = query.eq(filter.field, filter.value);
        // if (filter !== null) query = query[filter.method](filter.field, filter.value);
        const { data, error } = await query;
        if (error) {
          console.error(error);
          throw new Error('Bookings could not be loaded');
        }
        return data;
      }

  - useBookings.js:
      export function useBookings() {
        const [searchParams] = useSearchParams();
        // FILTER
        const filterValue = searchParams.get('status');
        const filter =
          !filterValue || filterValue === 'all' ? null : { field: 'status', value: filterValue };
        const {
          isLoading,
          data: bookings,
          error,
        } = useQuery({
          queryKey: ['bookings', filter],    --- dependancy array to re-fetch data (all data from applied filters will be cached)
          queryFn: () => getBookings({ filter }),
        });

- 380. API-Side Sorting: Sorting Bookings
  - apiBookings.js:
      ....
        if (sortBy) query = query.order(sortBy.field, { ascending: sortBy.direction === 'asc' });
      ....

  - useBookings.js:
      ....
        const sortByRaw = searchParams.get('sortBy') || 'startDate-desc';
        const [field, direction] = sortByRaw.split('-');
        const sortBy = { field, direction };
        const {
          isLoading,
          data: bookings,
          error,
        } = useQuery({
          queryKey: ['bookings', filter, sortBy],
          queryFn: () => getBookings({ filter, sortBy }),
        });
      ....

- 381. Building a Reusable Pagination Component
          const Pagination = ({ count }) => {
            const [searchParams, setSearchParams] = useSearchParams();
            const currentPage = !searchParams.get('page') ? 1 : Number(searchParams.get('page'));
            const pageCount = Math.ceil(count / PAGE_SIZE);
            function nextPage() {
              const next = currentPage === pageCount ? currentPage : currentPage + 1;
              searchParams.set('page', next);
              setSearchParams(searchParams);
            }
            function prevPage() {
              const prev = currentPage === 1 ? currentPage : currentPage - 1;
              searchParams.set('page', prev);
              setSearchParams(searchParams);
            }
            if (pageCount <= 1) return null;
            return (
              <StyledPagination>
                <P>
                  Showing <span>{(currentPage - 1) * PAGE_SIZE + 1}</span> to{' '}
                  <span>{currentPage === pageCount ? count : currentPage * PAGE_SIZE}</span> of{' '}
                  <span>{count}</span> results
                </P>
                <Buttons>
                  <PaginationButton onClick={prevPage} disabled={currentPage === 1}>
                    <HiChevronLeft /> <span>Previous</span>
                  </PaginationButton>
                  <PaginationButton onClick={nextPage} disabled={currentPage === pageCount}>
                    <span>Next</span>
                    <HiChevronRight />
                  </PaginationButton>
                </Buttons>
              </StyledPagination>
            );
          };
          ------
          ...
                  <Table.Footer>
                    <Pagination count={5} />
                  </Table.Footer>
                </Table>

- 382. API-Side Pagination: Paginating Bookings

        export async function getBookings({ filter, sortBy, page }) {
          let query = supabase
            .from('bookings')
            .select(
              'id, created_at, startDate, endDate, numNights, numGuests, status, totalPrice, cabins(name), guests(fullName, email)',
              { count: 'exact' },
            );
          // FILTER
          if (filter) query = query.eq(filter.field, filter.value);
          // SORT
          if (sortBy) query = query.order(sortBy.field, { ascending: sortBy.direction === 'asc' });
          if (page) {
            const from = (page - 1) * PAGE_SIZE;
            const to = from + PAGE_SIZE - 1;

            query = query.range(from, to);
          }
          const { data, error, count } = await query;
          if (error) {
            console.error(error);
            throw new Error('Bookings could not be loaded');
          }
          return { data, count };
        }
        ------
        export function useBookings() {
          const [searchParams] = useSearchParams();
          // FILTER
          const filterValue = searchParams.get('status');
          const filter =
            !filterValue || filterValue === 'all' ? null : { field: 'status', value: filterValue };
          // SORT
          const sortByRaw = searchParams.get('sortBy') || 'startDate-desc';
          const [field, direction] = sortByRaw.split('-');
          const sortBy = { field, direction }
          // PAGINATION
          const page = !searchParams.get('page') ? 1 : Number(searchParams.get('page'));
          const {
            isLoading,
            data: { data: bookings, count } = {},
            error,
          } = useQuery({
            queryKey: ['bookings', filter, sortBy, page],
            queryFn: () => getBookings({ filter, sortBy, page }),
          });
          return { isLoading, error, bookings, count };
        }

- 383. Prefetching With React Query

      const queryClient = useQueryClient();
      .......
      // PRE-FETCHING
      const pageCount = Math.ceil(count / PAGE_SIZE);
      if (page < pageCount)
        queryClient.prefetchQuery({
          queryKey: ['bookings', filter, sortBy, page + 1],
          queryFn: () => getBookings({ filter, sortBy, page: page + 1 }),
        });
      if (page > 1)
        queryClient.prefetchQuery({
          queryKey: ['bookings', filter, sortBy, page - 1],
          queryFn: () => getBookings({ filter, sortBy, page: page - 1 }),
        });
      .....

- 384. Building the Single Booking Page

  - Default behaviour of react is to try fetch data 3 times, but we can disabled it:
    const {
      isLoading,
      data: booking,
      error,
    } = useQuery({
      queryKey: ['booking'],
      queryFn: () => getBooking(bookingId),
      retry: false,    ----- !!!!!
    });

  - Add new routing in App.jsx:
      .....
      <Route path="booking/:bookingId" element={<Booking />} />
      .....

  - Add new component in Booking.jsx:
      const Booking = () => {
        return <BookingDetail />;
      };

  - Add fetching data in BookingDetail.jsx from useBooking.jsx:
      function BookingDetail() {
        const { booking, isLoading } = useBooking();
        const moveBack = useMoveBack();
        if (isLoading) return <Spinner />;
        const { status, id: bookingId } = booking;
        .....

  - UseBooking implementation:
      export function useBooking() {
        const { bookingId } = useParams();
        const {
          isLoading,
          data: booking,
          error,
        } = useQuery({
          queryKey: ['booking'],
          queryFn: () => getBooking(bookingId),
          retry: false,
        });
        ....

- 385. Checking In a Booking

  - See implementation in commit.

      export function useCheckin() {
        const queryClient = useQueryClient();
        const navigate = useNavigate();

        const { mutate: checkin, isLoading: isCheckingIn } = useMutation({
          mutationFn: (bookingId) =>
            updateBooking(bookingId, {
              status: 'checked-in',
              isPaid: true,
            }),

          onSuccess: (data) => {
            toast.success(`Booking #${data.id} successfully checked in`);
            queryClient.invalidateQueries({ active: true }); // true - instead of query key, just do for all queries
            navigate('/');
          },

          onError: () => toast.error('There was an error while checking in'),
        });

        return { checkin, isCheckingIn };
      }
      ---------
      function CheckinBooking() {
        const [confirmPaid, setConfirmPaid] = useState(false);
        const { booking, isLoading } = useBooking();
        useEffect(() => setConfirmPaid(booking?.isPaid ?? false), [booking]);
        const moveBack = useMoveBack();
        const { checkin, isCheckingIn } = useCheckin();

        if (isLoading) return <Spinner />;

        const { id: bookingId, guests, totalPrice, numGuests, hasBreakfast, numNights } = booking;

        function handleCheckin() {
          if (!confirmPaid) return;
          checkin(bookingId);
        }

        return (
          <>
            <Row type="horizontal">
              <Heading as="h1">Check in booking #{bookingId}</Heading>
              <ButtonText onClick={moveBack}>&larr; Back</ButtonText>
            </Row>

            <BookingDataBox booking={booking} />

            <Box>
              <Checkbox
                checked={confirmPaid}
                disabled={confirmPaid || isCheckingIn}
                onChange={() => setConfirmPaid((confirm) => !confirm)}
                id="confirm"
              >
                I confirm that {guests.fullname} has paid the total amount of {formatCurrency(totalPrice)}
              </Checkbox>
            </Box>

            <ButtonGroup>
              <Button onClick={handleCheckin} disabled={!confirmPaid || isCheckingIn}>
                Check in booking #{bookingId}
              </Button>
              <Button variation="secondary" onClick={moveBack}>
                Back
              </Button>
            </ButtonGroup>
          </>
        );
      }
      
- 386. Adding Optional Breakfast

export function useCheckin() {
.......
  const { mutate: checkin, isLoading: isCheckingIn } = useMutation({
    mutationFn: ({ bookingId, breakfast }) =>
      updateBooking(bookingId, {
        status: 'checked-in',
        isPaid: true,
        ...breakfast,
      }),
------
function CheckinBooking() {
  const [confirmPaid, setConfirmPaid] = useState(false);
  const [addBreakfast, setAddBreakfast] = useState(false);
  const { booking, isLoading } = useBooking();
  const { settings, isLoading: isLoadingSettings } = useSettings();
  ....
  if (isLoading || isLoadingSettings) return <Spinner />;
  const { id: bookingId, guests, totalPrice, numGuests, hasBreakfast, numNights } = booking;
  const optionalBreakfastPrice = settings.breakfastPrice * numNights * numNights;
  function handleCheckin() {
    if (!confirmPaid) return;
    if (addBreakfast) {
      checkin({
        bookingId,
        breakfast: {
          hasBreakfast: true,
          extrasPrice: optionalBreakfastPrice,
          totalPrice: totalPrice + optionalBreakfastPrice,
        },
      });
    } else {
      checkin({ bookingId, breakfast: {} });
    }
  }
  .....
      {!hasBreakfast && (
        <Box>
          <Checkbox
            checked={addBreakfast}
            onChange={() => {
              setAddBreakfast((add) => !add);
              setConfirmPaid(false);
            }}
            id="breakfast"
          >
            Want to add breakfast for {formatCurrency(optionalBreakfastPrice)}?
          </Checkbox>
        </Box>
      )}
      <Box>
        <Checkbox
          checked={confirmPaid}
          disabled={confirmPaid || isCheckingIn}
          onChange={() => setConfirmPaid((confirm) => !confirm)}
          id="confirm"
        >
          I confirm that {guests.fullname} has paid the total amount of{' '}
          {!addBreakfast
            ? formatCurrency(totalPrice)
            : `${formatCurrency(totalPrice + optionalBreakfastPrice)} (${formatCurrency(
                totalPrice,
              )} + ${formatCurrency(optionalBreakfastPrice)})`}
        </Checkbox>
      </Box>

- 387. Checking Out a Booking (+ Fixing a Small Bug)

        export function useCheckout() {
          const queryClient = useQueryClient();
          const { mutate: checkout, isLoading: isCheckingOut } = useMutation({
            mutationFn: (bookingId) =>
              updateBooking(bookingId, {
                status: 'checked-out',
              }),
            onSuccess: (data) => {
              toast.success(`Booking #${data.id} successfully checked out`);
              queryClient.invalidateQueries({ active: true }); // true - instead of query key, just do for all queries
            },
        .....
        -----
        function BookingRow({
          ...
          const { checkout, isCheckingOut } = useCheckout();
          ....
                    {status === 'checked-in' && (
                    <Menus.Button
                      icon={<HiArrowUpOnSquare />}
                      onClick={() => {
                        checkout(bookingId);
                      }}
                      disabled={isCheckingOut}
                    >
                      Check out
                    </Menus.Button>
                  )}
          ....
          -----
          function BookingDetail() {
          .....
          const { checkout, isCheckingOut } = useCheckout();
          ....
                  {status === 'checked-in' && (
                  <Button
                    onClick={() => {
                      checkout(bookingId);
                    }}
                    disabled={isCheckingOut}
                  >
                    Check out
                  </Button>
                )}
          .....
          -----

- 388. Deleting a Booking

    - To close modal menu right after success/error of deleteing (close modal)
        <Modal>
          <Modal.Open opens="delete">
            <Button variation="danger">Delete booking</Button>
          </Modal.Open>

          <Modal.Window name="delete">
            <ConfirmDelete
              resourceName="bookings"
              disabled={isDeleting}
              onConfirm={() => deleteBooking(bookingId, { onSettled: () => navigate(-1) })} ---- !!!!
            />
          </Modal.Window>
        </Modal>

- 389. Authentication: User Login With Supabase

  - Create new user in Supabase:
    - Go to Authentification 
    - You can choose different providers (sso) Now just use email 
    - add new user
    - Go to API Docs -> User Management (supabase uses JWT technology to auth)
    - Copy 'USER LOGIN'

      export async function login({ email, password }) {
        let { data, error } = await supabase.auth.signInWithPassword({
          email,
          password,
        });
        if (error) throw new Error(error.message);
        return data;
      }
      ----
      export function useLogin() {
        const navigate = useNavigate();
        const { mutate: login, isLoading } = useMutation({
          mutationFn: ({ email, password }) => loginApi({ email, password }),
          onSuccess: (user) => {
            navigate('/dashboard');
          },
          onError: (err) => {
            console.log('ERROR', err);
            toast.error('Provided email or password are incorrect');
          },
        });
        return { login, isLoading };
      }
      ----
      ...
        const [email, setEmail] = useState('vova@example.com');
        const [password, setPassword] = useState('1234567');
        const { login, isLoading } = useLogin();

        function handleSubmit(e) {
          e.preventDefault();
          if (!email || !password) return;
          login({ email, password });
        }
        ...

- 390. Authorization: Protecting Routes

  - Clear login form right after submitting:
  function handleSubmit(e) {
    e.preventDefault();
    if (!email || !password) return;
    login(
      { email, password },
      {
        onSettled: () => {
          setEmail('');
          setPassword('');
          ....

  - Make protected component for App Layout:
          <Route
            element={
              <ProtectedRoute>
                <AppLayout />
              </ProtectedRoute>
            }
          >
            <Route index element={<Navigate replace to="dashboard" />} />
            <Route path="dashboard" element={<Dashboard />} />
            ....

  - Protected component:
    const FullPage = styled.div`
      height: 100vh;
      background-color: var(--color-grey-50);
      display: flex;
      align-items: center;
      justify-content: center;
    `;
    const ProtectedRoute = ({ children }) => {
      const navigate = useNavigate();
      // 1. Load authenticated user
      const { user, isLoading, isAuthenticated } = useUser();
      // 2. If there is NO authenticated user, redirect to the /login
      useEffect(
        function () {
          if (!isAuthenticated && !isLoading) navigate('/login');
        },
        [isAuthenticated, isLoading, navigate],
      );
      // 3. While loading, show a spinner
      if (isLoading)
        return (
          <FullPage>
            <Spinner />
          </FullPage>
        );

      // 4. If there IS a user, render the app
      if (isAuthenticated) return children;
    };
    export default ProtectedRoute;

  - export async function getCurrentUser() {
      const { data: session } = await supabase.auth.getSession();
      if (!session.session) return null;
      const { data, error } = await supabase.auth.getUser();
      if (error) throw new Error(error.message);
      return data?.user;
    }

  - export function useUser() {
        const { isLoading, data: user } = useQuery({
          queryKey: ['user'],
          queryFn: getCurrentUser,
        });
        return { isLoading, user, isAuthenticated: user?.role === 'authenticated' };
      }

  - Cache login user data:
      export function useLogin() {
      const queryClient = useQueryClient();
      ....
      const { mutate: login, isLoading } = useMutation({
        mutationFn: ({ email, password }) => loginApi({ email, password }),
        onSuccess: (user) => {
          queryClient.setQueriesData(['user'], user);
          navigate('/dashboard');
        },
      ....

391. User Logout

const Header = () => {
  return (
    <StyledHeader>
      <Logout />
    </StyledHeader>
......
const Logout = () => {
  const { logout, isLoading } = useLogout();
  return (
    <ButtonIcon disabled={isLoading} onClick={logout}>
      {!isLoading ? <HiArrowRightOnRectangle /> : <SpinnerMini />}
    </ButtonIcon>
.....
export function useLogout() {
  const navigate = useNavigate();
  const queryClient = useQueryClient();
  const { mutate: logout, isLoading } = useMutation({
    mutationFn: logoutApi,
    onSuccess: () => {
      queryClient.removeQueries();
      navigate('/login', { replace: true });
.....
export async function logout() {
  const { error } = supabase.auth.signOut();
  if (error) throw new Error(error.message);
}

392. Fixing an Important Bug
Relogin didn't work after logout and navigation to the root page.

export function useLogin() {
....
  const { mutate: login, isLoading } = useMutation({
    mutationFn: ({ email, password }) => loginApi({ email, password }),
    onSuccess: (user) => {
      queryClient.setQueryData(['user'], user.user); ------!!!! (was: queryClient.setQueriesData(['user'], user))
      navigate('/dashboard', { replace: true });
    },
....

393. Building the Sign Up Form

function SignupForm() {
  const { register, formState, getValues, handleSubmit } = useForm();
  const { errors } = formState;

  function onSubmit(data) {
    console.log(data);
  }

  return (
    <Form onSubmit={handleSubmit(onSubmit)}> ------- our own handling of submit 
      <FormRow label="Full name" error={errors?.fullName?.message}>
        <Input
          type="text"
          id="fullName"
          {...register('fullName', { required: 'This field is required' })} --- use useForm hook to set required field
        />
      </FormRow>

      <FormRow label="Email address" error={errors?.email?.message}>
        <Input
          type="email"
          id="email"
          {...register('email', {
            required: 'This field is required',
            pattern: { value: /\S+@\S+\.\S+/, message: 'Please provide a valid email address' }, ---- set pattern validation
          })}
        />
      </FormRow>

      <FormRow label="Password (min 8 characters)" error={errors?.password?.message}>
        <Input
          type="password"
          id="password"
          {...register('password', {
            required: 'This field is required',
            minLength: {    ------ min length valkidation
              value: 8,
              message: 'Password needs a minimum of 8 characters',
            },
          })}
        />
      </FormRow>

      <FormRow label="Repeat password" error={errors?.passwordConfirm?.message}>
        <Input
          type="password"
          id="passwordConfirm"
          {...register('passwordConfirm', {
            required: 'This field is required',
            validate: (value) => value === getValues().password || 'Passwords need to match',    -----validation the similarity of passwords
          })}
        />
      </FormRow>

      <FormRow>
        {/* type is an HTML attribute! */}
        <Button variation="secondary" type="reset">
          Cancel
        </Button>
        <Button>Create new user</Button>
      </FormRow>
    </Form>
  );
}

394. User Sign Up

https://temp-mail.org/en/ - service to have temporary emails for testing

Configure auth with cinfirmation email in Supabase:
- Authentification/Users - all existing users and their status
- Authentification/Providers/Email - 'Confirm Email'=true
- Authentification/Email Templates - configure email Templates
- Authentification/URL Configuration - config on which should be redirected after confirmation

------
export async function signup({ fullName, email, password }) {
  const { data, error } = await supabase.auth.signUp({
    email,
    password,
    options: {
      data: {
        fullName,
        avatar: '',
      },
    },
  });
  if (error) throw new Error(error.message);
  return data;
}
-----
export function useSignup() {
  const { mutate: signup, isLoading } = useMutation({
    mutationFn: signupApi,
    onSuccess: (user) => {
      toast.success(
        "Accoount successfully created! Please verify the new account from the user's email address",
      );
    },
  });
  return { signup, isLoading };
}
-------
function SignupForm() {
  const { signup, isLoading } = useSignup();
  const { register, formState, getValues, handleSubmit } = useForm();
  const { errors, reset } = formState;

  function onSubmit({ fullName, email, password }) {
    signup(
      { fullName, email, password },
      {
        onSettled: () => reset(),
      },
    );
  }
.....

395. Authorization on Supabase: Protecting Database (RLS)

RLS - row level security policy

- Authentification/Policies - Update each action with authentificated user

396. Building The App Header

const StyledHeader = styled.header`
  background-color: var(--color-grey-0);
  padding: 1.2rem 4.8rem;
  border-bottom: 1px solid var(--color-grey-100);

  display: flex;
  gap: 2.4rem;
  align-items: center;
  justify-content: flex-end;
`;

const Header = () => {
  return (
    <StyledHeader>
      <UserAvatar />
      <HeaderMenu />
    </StyledHeader>
  );
};


see other implementation in code

397. Updating User Data and Password

see whole implementation in code

- 398. Implementing Dark Mode With CSS Variables

    - Fix later loading changed avatar:
    .....
      const { mutate: updateUser, isLoading: isUpdating } = useMutation({
        mutationFn: updateCurrentUser,
        onSuccess: ({user}) => {
          toast.success('User account successfully updated');
          queryClient.setQueryData(['user'], user);                  ------!!!!!!
          // queryClient.invalidateQueries({ queryKey: ['user'] });  ------!!!!!!
        },
        onError: (err) => toast.error(err.message),
      });
    .....
      function handleSubmit(e) {
        e.preventDefault();
        if (!fullName) return;
        updateUser(
          { fullName, avatar },
          {
            onSuccess: () => {           ------!!!!!!
              setAvatar(null);
              e.target.reset();
            },
          },
        );
      }
    .....
    I haven't noticed these changes

    - Dark Mode
    ....
    Update GlobalStyles
     &, &.light-mode {....}
     &.dark-mode {....}
    ....
    Add DarkToggleMode component 
    const DarkModeToggle = () => {
      const { isDarkMode, toggleDarkMode } = useDarkMode();
      return (
        <ButtonIcon onClick={toggleDarkMode}>
          {isDarkMode ? <HiOutlineSun /> : <HiOutlineMoon />}
        </ButtonIcon>
      );
    };
    .....
    add /Users/volodymyrchubenko/Documents/Repos/Personal/Udemy/ultimate-react-course/17-the-wild-oasis/the-wild-oasis/src/context/DarkModeContext.jsx
    const DarkModeContext = createContext();
      function DarkModeProvider({ children }) {
        const [isDarkMode, setIsDarkMode] = useLocalStorageState(false, 'isDarkMode');
        useEffect(
          function () {
            if (isDarkMode) {
              document.documentElement.classList.add('dark-mode');
              document.documentElement.classList.remove('light-mode');
            } else {
              document.documentElement.classList.add('light-mode');
              document.documentElement.classList.remove('dark-mode');
            }
          },
          [isDarkMode],
        );
        function toggleDarkMode() {
          setIsDarkMode((isDark) => !isDark);
        }
        return (
          <DarkModeContext.Provider value={{ isDarkMode, toggleDarkMode }}>
            {children}
          </DarkModeContext.Provider>
        );
      }
      function useDarkMode() {
        const context = useContext(DarkModeContext);
        if (context === undefined) throw Error('DarkModeContext was used outside of DarkModeProvider');
        return context;
      }
      export { DarkModeProvider, useDarkMode };
    ....
    use context to udate Logo
    function Logo() {
      const { isDarkMode } = useDarkMode();
      const src = isDarkMode ? '/logo-dark.png' : '/logo-light.png';
    .....
    Add context provider
    const App = () => {
    return (
      <DarkModeProvider>
        <QueryClientProvider client={queryClient}>
        ....

- 399. Building the Dashboard Layout
    - see implementation in code

- 400. Computing Recent Bookings and Stays
...
export async function getBookingsAfterDate(date) {
  const { data, error } = await supabase
    .from('bookings')
    .select('created_at, totalPrice, extrasPrice')
    .gte('created_at', date)
    .lte('created_at', getToday({ end: true }));
  if (error) {
    console.error(error);
    throw new Error('Bookings could not get loaded');
  }
  return data;
}
...
export function useRecentBookings() {
  const [searchParams] = useSearchParams();
  const numDays = !searchParams.get('last') ? 7 : Number(searchParams.get('last'));
  const queryDate = subDays(new Date(), numDays).toISOString()
  const { isLoading, data: bookings } = useQuery({
    queryFn: () => getBookingsAfterDate(queryDate),
    queryKey: ['bookings', `last-${numDays}`],
  });
  return { isLoading, bookings };
}
...
  const { bookings, isLoading: isLoading1 } = useRecentBookings();
  if (isLoading1 || isLoading2) return <Spinner />;

- 401. Displaying Statistics
    see implementation: 
      - 17-the-wild-oasis/the-wild-oasis/src/features/dashboard/Stats.jsx
      - 17-the-wild-oasis/the-wild-oasis/src/features/dashboard/useRecentStays.js
      - 17-the-wild-oasis/the-wild-oasis/src/features/dashboard/DashboardLayout.jsx

- 402. Displaying a Line Chart With the Recharts Library

    - Install recharts lib for creation of charts:
    npm i recharts@2
    https://recharts.org/en-US/
    .....
          <SalesChart bookings={bookings} numDays={numDays} />
    .....
      const SalesChart = ({ bookings, numDays }) => {
        const { isDarkMode } = useDarkMode();
        const allDates = eachDayOfInterval({ start: subDays(new Date(), numDays - 1), end: new Date() });
        const data = allDates.map((date) => {
          return {
            label: format(date, 'MMM dd'),
            totalSales: bookings
              .filter((booking) => isSameDay(date, new Date(booking.created_at)))
              .reduce((acc, cur) => acc + cur.totalPrice, 0),
            extrasSales: bookings
              .filter((booking) => isSameDay(date, new Date(booking.created_at)))
              .reduce((acc, cur) => acc + cur.extraPrice, 0),
          };
        });
        const colors = isDarkMode
          ? {
              totalSales: { stroke: '#4f46e5', fill: '#4f46e5' },
              extrasSales: { stroke: '#22c55e', fill: '#22c55e' },
              text: '#e5e7eb',
              background: '#18212f',
            }
          : {
              totalSales: { stroke: '#4f46e5', fill: '#c7d2fe' },
              extrasSales: { stroke: '#16a34a', fill: '#dcfce7' },
              text: '#374151',
              background: '#fff',
            };
        return (
          <StyledSalesChart>
            <Heading as="h2">Sales</Heading>
            <ResponsiveContainer height={300} width="100%">
              <AreaChart data={data}>
                <XAxis dataKey="label" tick={{ fill: colors.text }} tickLine={{ stroke: colors.text }} />
                <YAxis unit="$" tick={{ fill: colors.text }} tickLine={{ stroke: colors.text }} />
                <CartesianGrid strokeDasharray="4" />
                <Tooltip contentStyle={{ backgroundColor: colors.background }} />
                <Area
                  dataKey="totalSales"
                  type="monotone"
                  stroke={colors.totalSales.stroke}
                  fill={colors.totalSales.fill}
                  strokeWidth={2}
                  name="Total sales"
                  unit="$"
                />
                <Area
                  dataKey="extrasSales"
                  type="monotone"
                  stroke={colors.extrasSales.stroke}
                  fill={colors.extrasSales.fill}
                  strokeWidth={2}
                  name="Extras sales"
                  unit="$"
                />
              </AreaChart>
            </ResponsiveContainer>
          </StyledSalesChart>
        );
      };
      export default SalesChart;

- 403. Displaying a Pie Chart
const DurationChart = ({confirmedStays}) => {
  const { isDarkMode } = useDarkMode();
  const startData = isDarkMode ? startDataDark : startDataLight;
  const data = prepareData(startData, confirmedStays);
  return (
    <ChartBox>
      <Heading as="h2">Stay duration summary</Heading>
      <ResponsiveContainer width="100%" height={240}>
        <PieChart>
          <Pie
            data={data}
            nameKey="duration"
            dataKey="value"
            innerRadius={85}
            outerRadius={110}
            cx="40%"
            cy="50%"
            paddingAngle={3}
          >
            {data.map((entry) => (
              <Cell fill={entry.color} stroke={entry.color} key={entry.duration} />
            ))}
          </Pie>
          <Tooltip />
          <Legend
            verticalAlign="middle"
            align="right"
            width="30%"
            layout="vertical"
            iconSize={15}
            iconType="circle"
          />
        </PieChart>
      </ResponsiveContainer>
    </ChartBox>
  );
};

- 404. Displaying Stays for Current Day

See button as a link:
function TodayItem({ activity }) {
  const { id, status, guests, numNights } = activity;

  return (
    <StyledTodayItem>
      {status === 'unconfirmed' && <Tag type="green">Arriving</Tag>}
      {status === 'checked-in' && <Tag type="blue">Departing</Tag>}

      <Flag src={guests.countryFlag} alt={`Flag of ${guests.country}`} />
      <Guest>{guests.fullName}</Guest>
      <div>{numNights} nights</div>

      {status === 'unconfirmed' && (
        <Button size="small" variation="primary" as={Link} to={`/checkin/${id}`}>
          Check in
        </Button>
      )}

      {status === 'checked-in' && <CheckoutButton bookingId={id} />}
    </StyledTodayItem>
  );
}

- 405. Error Boundaries

  npm install react-error-boundary

  wrap the root of application components with error boundary component passing as a prop error component to display.
  It catch error only when React is rendering

    import React from 'react';
    import ReactDOM from 'react-dom/client';
    import App from './App';
    import { ErrorBoundary } from 'react-error-boundary';
    import ErrorFallback from './ui/ErrorFallback';

    ReactDOM.createRoot(document.getElementById('root')).render(
      <React.StrictMode>
        <ErrorBoundary FallbackComponent={ErrorFallback} onReset={() => window.location.replace('/')}>
          <App />
        </ErrorBoundary>
      </React.StrictMode>,
    );

    ------

    ....
    const ErrorFallback = ({ error, resetErrorBoundary }) => {
    return (
      <>
        <GlobalStyles />
        <StyledErrorFallback>
          <Box>
            <Heading as="h1">Something went wrong üßê</Heading>
            <p>{error.message}</p>
            <Button size="large" onClick={resetErrorBoundary}>
              Try again
            </Button>
          </Box>
        </StyledErrorFallback>
      </>
    );
  };

- 406. Final Touches + Fixing Bugs

Fix close menu after clicking again on menu button
  function handleClick(e) {
    e.stopPropagation(); // handling one click once (capturing or bubbling phase)
    .....
  ------
  function List({ id, children }) {
    const { openId, position, close } = useContext(MenusContext);
    const ref = useOutsideClick(close, false); // use only bubbling phase
    ....

  
  Change dark mode regarding in the system preferences:
  function DarkModeProvider({ children }) {
    const [isDarkMode, setIsDarkMode] = useLocalStorageState(
      window.matchMedia('(preferes-color-scheme: dark)').matches,
      'isDarkMode',
    );
    .....

*****************************************************************************************************************
Section 30: Deployment With Netlify and Vercel
*****************************************************************************************************************

- 407. Section Overview
- 408. Deploying to Netlify

1. npm run build - build the project via Vite
// '/dist' folder will be created for farther deploying, for instance in Netlify

2. Create file './dist/netlify.toml' with next content (Better to create it in './publlick' folder) it will be added automatically to dist during building the project:
[[redirects]]
from = "/*"
to = "/index.html"
status = 200

3. Go to:
https://app.netlify.com/teams/forelock7/sites
sites -> add new -> deploy manually -> Drag and drop './dist' folder

4. You can change site name(URL)

- 409. Setting Up a Git and GitHub Repository
- 410. Deploying to Vercel

*****************************************************************************************************************
Section 31: PART 5: FULL-STACK REACT WITH NEXT.JS [1 PROJECT]
*****************************************************************************************************************

Here are some high-quality resources that you might find helpful while studying this Part 5. (The list follows the order of sections in this part)

These resources are 100% optional, but might give you additional insights or provide ever deeper dives into some topics.

üëâ 28 advanced Next.js features that everyone should know (A must-read for everyone after finishing the course! ‚òùÔ∏è)

üëâ How React Server Components work (We cover React Server Components (RSC) in great detail, but here is another look at them, with a few more visualizations. Written before RSC was available anywhere, but still good)

üëâ RSC DevTools (A nice way of visualizing the RSC payload right in Chrome's DevTools)

üëâ Next.js Image Component Tutorial (Going even more deep into the <Image /> component than we do in the course)

üëâ Understanding Next.js cache (We cover caching in detail in the course, but this is another very good article on caching)

üëâ Static Site Generation (SSG) Next.js documentation page

üëâ High-quality open-source Next.js app for learning (A huge modern Next.js codebase that you can learn a lot from)

*****************************************************************************************************************
Section 32: Overview of Next.js With the "App" Router
*****************************************************************************************************************

- 414. Download Fresh Starter Files + Slides!
  theory-slides-v1.1.pdf

- 415. An Overview of Server-Side Rendering (SSR)
 
- 416. Experiment: Manual SSR With React DOM + Node.js

node server.js - run js file by node js
node --watch server.js - run js file by node js and watch for changes in file

npm i -D @babel/core @babel/preset-env @babel/preset-react @babel/register 
npm i react react-dom

after setting up babel use next to run project:
node --watch start.js

- 417. The Missing Piece: Hydration

- 418. Implementing Hydration

- 419. What is Next.js?

- 420. Setting Up a Next.js Project

npx create-next-app@14 the-wild-oasis-website
with options:
‚úî Would you like to use TypeScript? ‚Ä¶ No 
‚úî Would you like to use ESLint? ‚Ä¶ Yes
‚úî Would you like to use Tailwind CSS? ‚Ä¶  Yes
‚úî Would you like to use `src/` directory? ‚Ä¶ No 
‚úî Would you like to use App Router? (recommended) ‚Ä¶ Yes
‚úî Would you like to customize the default import alias (@/*)? ‚Ä¶ No

- 422. Defining Routes and Pages

Update settings 'custom labels' in VSCode to rename tabs because all page scripst have name: page.js
item: **/app/**/page.js 
value: Page: ${dirname}

- 423. Navigating Between Pages

export default function Page() {
  return (
    <div>
      <h1>The Wild Oasis. Welcome to paradise.</h1>
      <Link href="/cabins">Explore luxury cabins</Link>
    </div>
  );
}

- 424. Creating a Layout

project/app/layout.js
----
export const metadata = {
  title: 'The Wild Oasis',   ---- title element is setting automaticaly (browser tab name)
};
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <header>
          <Logo />
          <Navigation />    ---- propagated to all pages, where 'children' is pages' content
        </header>
        <main>{children}</main>
        <footer>Copyright by The Wild Oasis</footer>
      </body>
    </html>
  );
}

- 425. What are React Server Components? (RSC ‚Äì Part 1)

- Client Components
- Server Components

- 426. Fetching Data in a Page

Let's use fake API to try this: https://jsonplaceholder.typicode.com/

export default async function Page() {
  const res = await fetch('https://jsonplaceholder.typicode.com/users');
  const data = await res.json();
  console.log(data);
  return (
    <div>
      <h1>Cabins page</h1>
      <ul>
        {data.map((user) => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </div>
  );
}

- 427. Adding Interactivity With Client Components

use effects only can be used in Client component

21-the-wild-oasis-website/the-wild-oasis-website/app/components/Counter.js
......
'use client';
import { useState } from 'react';
export default function Counter({ users }) {
  const [count, setCount] = useState(0);

  console.log(users);

  return (
    <div>
      <p>There are {users.length} users</p>
      <button onClick={() => setCount((c) => c + 1)}>{count}</button>
    </div>
  );
}
-----
21-the-wild-oasis-website/the-wild-oasis-website/app/cabins/page.js
.....
import Counter from '../components/Counter';
export default async function Page() {
...
  return (
    <div>
...

      <Counter users={data} />
    </div>
  );
}

- 428. Displaying a Loading Indicator
To add global loading indicator just add this component in /app dir:
21-the-wild-oasis-website/the-wild-oasis-website/app/loading.js
....
export default function Loading() {
  return <p>LOADING DATA...</p>;
}

- 429. How RSC Works Behind the Scenes (RSC ‚Äì Part 2)

RSC - React Server Component

- 430. RSC vs. SSR: How are They Related? (RSC ‚Äì Part 3)

SSR - Server-Side Rendering

*****************************************************************************************************************
Section 33: Starting to Build the "Wild Oasis" Website
*****************************************************************************************************************

- 432. Project Planning: "The Wild Oasis" Customer Website

Technologies:
+ Framework - NEXT.js
+ UI State management - Context API (or Redux)
+ BD/API - Supabase
+ Styling - tailwindcss

- 433. Project Organization

Better to have /app/components/ dir to store all reusable components. Not to store them in page folders
To avoid wrong routing, all othe dir should be named with underscore: "_components"

import Logo from '@/app/_components/Logo'; - alias could be used, where @ - represents a root folder

- 434. Styling With Tailwind CSS

To activate Tailwind just add this file:
/the-wild-oasis-website/app/_styles/globals.css

Some colors could be predefined in /the-wild-oasis-website/tailwind.config.js and use them as class:
module.exports = {
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          50: '#E1E8EF',
          100: '#D4DEE7',
          200: '#B7C7D7',
          300: '#99B0C7',
          400: '#7C99B6',
-------
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body className='bg-primary-950 text-gray-50 min-h-screen'>

Install icons lib from tailwind developers:
npm i @heroicons/react

- 435. Adding Page Metadata and Favicon

/the-wild-oasis-website/app/layout.js
export const metadata = {
  title: {
    template: '%s / The Wild Oasis',    ---- set template for other pages where title is already set
    default: 'Welcome / The Wild Oasis',
  },
  description:
    'Luxurious cabin hotel, located in the heart of the Italian Dolomites, surrounded by beautiful mountains and dark forests',
};

/the-wild-oasis-website/app/cabins/page.js
export const metadata = {
  title: 'Cabins',
};

To set icon for web-site? just need to place 'icon.png' into '/app' folder

- 436. Loading and Optimizing Fonts

import { Josefin_Sans } from 'next/font/google';
const josefin = Josefin_Sans({
  subsets: ['latin'],
  // display: 'swap', //-- somehow it doesn't work properly
});
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body className={`${josefin.className} bg-primary-950 text-primary-100 min-h-screen`}>
        <header>

- 437. Improving the Navigation and Root Layout

- 438. Optimizing Images With Next.js <Image /> Component

import logo from '@/public/logo.png';
function Logo() {
  return (
    <Link href="/" className="flex items-center gap-4 z-10">
      {/* <Image src="/logo.png" height="60" width="60" alt="The Wild Oasis logo" /> */}
      <Image src={logo} height="60" width="60" alt="The Wild Oasis logo" quality={100} /> --- import of image give us additional parameters to specify, like quality

- 439. Building the Home Page

import Image from 'next/image';
import bg from '@/public/bg.png';
export default function Page() {
  return (
    <main className="mt-24">
      <Image
        src={bg}   ---- direct import of image gives us placeholder and quality props
        fill ---- image fills entire viewport (like background) 
        placeholder="blur"   ---- show bur during loading the image
        quality={80}  --- just quality of image for optimization
        className="object-cover object-top"  --- cover element properly: fit image by cutting and place it always on the top during scrolling
        alt="Mountains and forests with two cabins"
      />

- 440. Building the About Page With Responsive Images

Make image responsive if we cannnot import image, for istance when image is downloaded from DB:

      <div className="relative aspect-square col-span-2">   --- relative aspect-square
        <Image
          src="/about-2.jpg"
          fill  ----- fill
          className="object-cover"   ----- object-cover
          alt="Family that manages The Wild Oasis"
        />
      </div>

- 441. Adding Nested Routes and Pages

npm i date-fns