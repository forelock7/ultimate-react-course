*****************************************************************************************************************
Section 3: A First Look at React
*****************************************************************************************************************

- Vanila JS - pure JS without any framework, but can be Jquery

- Vanila JS vs React: https://codesandbox.io/s/react-first-app-advice-52879f

- React - JS library for building user interfaces. 
1) Based on components - combining blocks of complex UI
2) Declarative 
 + describe how components look like and how they work using a declarative syntax called JSX.  
 + Declarative telling React what a component shoulld look like, based on current data/State
 + React is abstraction away from DOM: we never touch the DOM(like vanilla JS)
 + JSX: a syntax that combines HTML, CSS, JS as well as referencing other components.
3) State-driven: REACT reacts to state changes by re-rendering the UI. State -> Render -> UI(Component written with JSX) -> Action on UI -> Update state -> Re-render -> UI
4) JS library - React is just library (not framework), because it's only the 'view' layer. We need to pick multiple external libraries to build a comlete application. Complite frameworks built on top of React - NEXT.js, Remix
5) Extremely popular - a lot of companies use React
6) Created by facebook in 2011 by Jordan Walke

- Two option for setting up a project
1) create-react-app (complete 'starter kit', ESLint, Prettier, Jest etc) - slow and outdated technologies. It's used for small projects.
2) VITE - modern too. Need to manually set up ESLint. Extrimaly fast host replacement (HMR) and bundling. It's used for real projects

- NEXT.js and Remix framework provide more functionality than Vanila React by itself.

- Create React project from scratch using 'create-react-app' 
npx create-react-app@5 pizza-menu

- To run JS/TS inside VScode use 'Quokka.js' extansios

*****************************************************************************************************************
Section 5: Working With Components, Props, and JSX
*****************************************************************************************************************

- Start React project 
npm run start

- React apps are entirely made out of components
- building blocks of user inerfaces in React
- Piece of UI that has its own 'data', 'logic' and 'appearance' (how it works and looks)
- We build complex UIs by building multiple components and combining them
- Components can be reused, nested inside each other and pass data between them

- Component tree - to understand the structure (Parent and child components)

- Rules for functions of components:
1) function name must start with capital letter 
2) function must return murkup (html)
3) Each component can return only one element (correct: <div><h1>Bla</h1><h2>Bla</h2></div>, wrong: <h1>Bla</h1><h2>Bla</h2>)
4) Never nest component function in component function

- Component:
+ data
+ logic
+ appearance

- JSX:
  + Declarative syntax to describe what components look like and how they work
  + Components must return a block of JSX
  + Extension of JS that allows us to embed following elements into HTML:
    1) JS
    2) CSS
    3) React Components

- BABEL in React convert HTML with JSX into JS. (you can use just JS functions instead of JSX syntax)

- Imperative approach - "How to do this" - create elements via Vanila JS 
   + Manual DOM element selections and DOM traversing.
   + Step-by-Step DOM mutation until we reach the desired UI
- Declarative approach - "What we want"
   + Describe what UI should look like using JSX, based on current data
   + React is an abstraction away from DOM: we never touch the DOM
   + Instead, we think of the UI as a reflection of the current data

- alert can happen twice because of 'strict' mode 

- One technology per file (traditional)
- One component per file (React new paradigm)

- Use JS code in JSX syntax - just cover with {}
        <p>{props.ingredient}</p>

- props in React: if you need use something except string - use JS mode {}
      <Pizza
        name="Pizza Spinaci"
        ingredient="Tomato, mozarella, spinach, and ricotta cheese"
        photoName="pizzas/spinaci.jpg"
        price={10}
      />

- Props are used to pass data from parent to child component

- Props are read-only, they are immutable. This is one of React's strict Rules

- If you need to mutate props, you actually need state

- One-way Data Flow - Data can pass only from parent top child!!! (Angular has two-way data flow)
    + more predictable
    + easier to debug
    + more performant

- Challenge #1: https://codesandbox.io/s/profile-card-v1-2hrm4p?file=/src/index.js

- In JS moed {} you can place JS expression (reference vars, create arrays or objects, [].map? ternary operator)
- In JS mode statements are not allowed (if/else, for, switch)
- JSX can be written enywhere inside a components (in if/else, assign to vars, pass it into functions)
- Piece of JSX can only have one root element. If you need more, use <REact.Frgment> (or the short <>)

- If we use iteration in REact, you should use 'key' unique property to avoid console log errors
function Menu() {
  return (
    <main className="menu">
      <h2>Our menu</h2>

      <div>
        {pizzaData.map((pizza) => (
          <Pizza pizzaObj={pizza} key={pizza.name} />
        ))}
      </div>
    </main>
  );
}

- Shortcircuting in React. Use only boolean value (NOT truthy or falsy value), because boolean values are not returned:
      {numPizzas > 0 && (
        <ul className="pizzas">
          {pizzas.map((pizza) => (
            <Pizza pizzaObj={pizza} key={pizza.name} />
          ))}
        </ul>
      )}

- In LS mode we can use if/else statement or any other JS code, except code that produce some value

- common technic to return 'null'
function Pizza(props) {
  if (props.pizzaObj.soldOut) return null;
  return (
    <li className="pizza">
      <img src={props.pizzaObj.photoName} alt={props.pizzaObj.name} />
      <div>
        <h3>{props.pizzaObj.name}</h3>
        <p>{props.pizzaObj.ingredients}</p>
        <span>{props.pizzaObj.price}</span>
      </div>
    </li>
  );
}

- props can be destructuring
function Pizza(props)
function Pizza({ pizzaObj })

- React fragment - use if you need to combane 2 elements without wrappimg them into another one
        <>
          <p>
            Authentic Italian cuisine. 6 creative dishes to choose from. All from our stone oven,
            all organic, all delicious.
          </p>
          <ul className="pizzas">
            {pizzas.map((pizza) => (
              <Pizza pizzaObj={pizza} key={pizza.name} />
            ))}
          </ul>
        </>

- if you need add some key to React fragment, just use following fragment
<React.Fragment key={ghdsghd}>
.....
</ React.Fragment>

- three options in JSX
      <span>
        {level === "advanced" && "üí™"}
        {level === "intermediate" && "üëç"}
        {level === "begginer" && "üê£"}
      </span>

*****************************************************************************************************************
Section 6: State, Events, and Forms: Interactive Components
*****************************************************************************************************************

- Set style for element
        <button style={{ backgroundColor: '#7950f2', color: '#fff' }}>Previous</button>

- Set click event for element ('onClick')
<button style={{ backgroundColor: '#7950f2', color: '#fff' }} onClick={() => alert('Next')}>

- Alert Function immidiatly run (NOT valid for this case)
<button onClick={alert('Next')}>

- MOuse handler
onMouseEnter={() => alert('TEST')}

- Another way to define handler function
  ........
  function handlePrevious() {
    alert('Previous');
  }
  return (
    ........
        <button style={{ backgroundColor: '#7950f2', color: '#fff' }} onClick={handlePrevious}>
    ........

- State - data that a component can hold over time, necessary for information that it needs to remember trhoughout the app's lifecucle
- "Component's memory"
- Component state - single local component variable ("Piece of state", "State variable")
- Updating component state triggers React to re-render the component

- Component View - when component is rendered

- State allows:
    1) Upfate the component's view (by re-rendering)
    2) Persist local variables between renders

- Use state in code, where 'step' - variable, 'setStep' - function to update state, 'useState' - function to create a state with init value
  const [step, setStep] = useState(1);
  function handlePrevious() {
    if (step > 1) setStep(step - 1);
  }

- Do NOT update state like this:
step = step + 1

- Update State -> Re-render component -> View
- In React, a view is updated by re-rendering the component
- A component is re-rendered when its state is updated
- DATA <-> UI

- Use ONLY callback function to update State
    if (step < 3) setStep((s) => s + 1);
    // BAD PRACTICE:
    if (step < 3) setStep(step + 1);

- UI as a function of state. UI as a reflection of data changing pver time

- For data that should not trigger re-rendering UI do not use state

- Prevent default action when submit form
function Form() {
  function handleSubmit(e) {
    e.preventDefault();
  }
  return (
    <form className="add-form" onSubmit={handleSubmit}>
    .....

- State 
  + internal data, owned by component
  + Component "memory"
  + Can be updated by component itself
  + Updating state causes component to re-render
  + Used to make components interactive

- Props:
  + External data, owned by parent component
  + Similar to function parameters
  + Read-only
  + Receiving new props causes component to re-render. Usually when the parent's state has been updated
  + Used by parent to confugure child component ("settings")

  - https://codesandbox.io/s/react-exercise-flashcards-starter-sx254w?file=/src/App.js
  - https://codesandbox.io/s/date-counter-v2-d23kg4?file=/src/App.js

*****************************************************************************************************************
Section 7: Thinking In React: State Management
*****************************************************************************************************************

- The "Thinking in React" process:
  1. Break the desired UI into components and estab;ish the component tree
  2. Build a static version in React (without state)
  3. Think about state:                                       |
    + When to use state                                       |
    + Types of state: local vs global                         |
    + Where to place each piece of state                      | State managment
  4. Establish data flow:                                     |  
    + One-way data flow                                       |
    + Child-to-parent communication                           |
    + Accessing global state                                  |

- Local State - only for one or few components, chiled components
- Global State - many components. Shared state that accessible to every component in the entire applicatio. (by React Context API, Redux). Use firstly local state!!!!

- Pass function as props:
      export default function App() {
        ....
        function handleAddItems(item) {
          setItems((items) => [...items, item]);
        }
        return (
          <div className="app">
            ....
            <Form onAddItems={handleAddItems} />
            ....
          </div>
        );
      }
      function Form({ onAddItems }) {
          ......
          onAddItems(newItem);
          ......
        }

- "Lifting Up State" - just moving state of component to parent component if you need access to state of several sibling component. 
Child-to parent communication (inverse data flow): child updating parent state (data "flowing" up). Use set function of state in child to update state.

- Derived state(–ø–æ—Ö—ñ–¥–Ω–∏–π) - state that is computed from an existing piece of state or from props
Do not need to devide state of object to several states of elements of that object. Just use regular vars, no useState. State of object is the single state of thruth for related data.

- Sort items in alphabetical order
if (sortBy === 'description') sortedItems = items.slice().sort((a, b) => a.description.localeCompare(b.description));

- Sort by boolean and number:
  if (sortBy === 'packed') sortedItems = items.slice().sort((a, b) => Number(a.packed) - Number(b.packed));

  - 'children' Props
  props.children
  Example:
            <Button textColor="#fff" bgColor="#7950f2" onClick={handlePrevious}>
              <span>üëà</span> Previous
            </Button>
            ......
            function Button({ textColor, bgColor, onClick, children }) {
              return (
                <button style={{ backgroundColor: bgColor, color: textColor }} onClick={onClick}>
                  {children}
                </button>
              );
            }